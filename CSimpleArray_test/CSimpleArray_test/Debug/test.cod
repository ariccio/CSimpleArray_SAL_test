; Listing generated by Microsoft (R) Optimizing Compiler Version 18.00.31101.0 

	TITLE	c:\Users\alexander riccio\documents\visual studio 2013\Projects\CSimpleArray_test\CSimpleArray_test\test.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?m_nLevel@CTrace@ATL@@1IA			; ATL::CTrace::m_nLevel
PUBLIC	?m_nCategory@CTrace@ATL@@1IA			; ATL::CTrace::m_nCategory
PUBLIC	?m_nLastCategory@CTrace@ATL@@1IA		; ATL::CTrace::m_nLastCategory
PUBLIC	?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A	; ATL::CTrace::m_nMap
;	COMDAT ?m_nLevel@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLevel@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLevel
_BSS	ENDS
;	COMDAT ?m_nLastCategory@CTrace@ATL@@1IA
_BSS	SEGMENT
?m_nLastCategory@CTrace@ATL@@1IA DD 01H DUP (?)		; ATL::CTrace::m_nLastCategory
_BSS	ENDS
;	COMDAT ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A
_BSS	SEGMENT
?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A DB 02080H DUP (?) ; ATL::CTrace::m_nMap
_BSS	ENDS
;	COMDAT ?m_nCategory@CTrace@ATL@@1IA
_DATA	SEGMENT
?m_nCategory@CTrace@ATL@@1IA DD 0ffffffffH		; ATL::CTrace::m_nCategory
_DATA	ENDS
PUBLIC	_HRESULT_FROM_WIN32
PUBLIC	??$AtlMultiply@I@ATL@@YAJPAIII@Z		; ATL::AtlMultiply<unsigned int>
PUBLIC	?Allocate@CCRTAllocator@ATL@@SAPAXI@Z		; ATL::CCRTAllocator::Allocate
PUBLIC	?Free@CCRTAllocator@ATL@@SAXPAX@Z		; ATL::CCRTAllocator::Free
PUBLIC	??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
PUBLIC	??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
PUBLIC	?GetCategoryName@CTrace@ATL@@CAPA_WI@Z		; ATL::CTrace::GetCategoryName
PUBLIC	?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z		; ATL::CTrace::TraceV
PUBLIC	?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z		; ATL::CTrace::TraceV
PUBLIC	?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z	; ATL::CTrace::RegisterCategory
PUBLIC	??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
PUBLIC	??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
PUBLIC	?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
PUBLIC	?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
PUBLIC	??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
PUBLIC	??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
PUBLIC	?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::__autoclassinit2
PUBLIC	??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z	; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
PUBLIC	??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ	; ATL::CTraceFileAndLineInfo::operator()
PUBLIC	?_AtlRaiseException@ATL@@YAXKK@Z		; ATL::_AtlRaiseException
PUBLIC	?AtlThrowImpl@ATL@@YGXJ@Z			; ATL::AtlThrowImpl
PUBLIC	?__autoclassinit2@CWinApp@@QAEXI@Z		; CWinApp::__autoclassinit2
PUBLIC	_wmain
PUBLIC	??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
PUBLIC	??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
PUBLIC	?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEHABH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Add
PUBLIC	?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::RemoveAll
PUBLIC	??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEAAHH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::operator[]
PUBLIC	?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex
PUBLIC	?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXI@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::__autoclassinit2
PUBLIC	??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
PUBLIC	??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
PUBLIC	?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add
PUBLIC	?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXXZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::RemoveAll
PUBLIC	??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEAAHH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::operator[]
PUBLIC	?GetData@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QBEPAHXZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::GetData
PUBLIC	?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex
PUBLIC	?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXI@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::__autoclassinit2
PUBLIC	??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@ABH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper
PUBLIC	??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAPAXIPAH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>
PUBLIC	??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAXPAXPAH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>
PUBLIC	??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@ABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper
PUBLIC	??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAPAXIPAH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>
PUBLIC	??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAXPAXPAH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>
PUBLIC	??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@		; `string'
PUBLIC	??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
PUBLIC	??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ ; `string'
PUBLIC	??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ ; `string'
PUBLIC	??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@		; `string'
PUBLIC	??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ ; `string'
PUBLIC	??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA	; `ATL::AtlThrowImpl'::`2'::__LINE__Var
PUBLIC	??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ ; `string'
PUBLIC	??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?theApp@@3VCWinApp@@A				; theApp
PUBLIC	??_C@_1DM@EBFIOLIP@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?5?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@ ; `string'
PUBLIC	??_C@_1FE@OLJODHIP@?$AAF?$AAa?$AAt?$AAa?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAF?$AAC?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@ ; `string'
PUBLIC	??_C@_1NK@DHCIKOFO@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAa?$AAl?$AAe?$AAx?$AAa?$AAn?$AAd?$AAe?$AAr?$AA?5?$AAr?$AAi?$AAc?$AAc?$AAi?$AAo?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe@ ; `string'
EXTRN	_atexit:PROC
EXTRN	__imp__wcscpy_s:PROC
EXTRN	__imp__wcslen:PROC
EXTRN	__imp__GetCommandLineW@0:PROC
EXTRN	__imp__RaiseException@16:PROC
EXTRN	__imp__GetModuleHandleW@4:PROC
EXTRN	__imp____iob_func:PROC
EXTRN	__imp__fwprintf:PROC
EXTRN	__imp__swprintf_s:PROC
EXTRN	__imp___vsnwprintf_s:PROC
EXTRN	__imp___vscwprintf:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp___recalloc:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	?AfxThrowMemoryException@@YGXXZ:PROC		; AfxThrowMemoryException
EXTRN	?AfxThrowOleException@@YGXJ@Z:PROC		; AfxThrowOleException
EXTRN	?AfxWinInit@@YGHPAUHINSTANCE__@@0PA_WH@Z:PROC	; AfxWinInit
EXTRN	??0CWinApp@@QAE@PB_W@Z:PROC			; CWinApp::CWinApp
EXTRN	??1CWinApp@@UAE@XZ:PROC				; CWinApp::~CWinApp
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	___security_cookie:DWORD
;	COMDAT ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A
_BSS	SEGMENT
?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A DD 01H DUP (?) ; ATL::atlTraceException
_BSS	ENDS
_BSS	SEGMENT
?theApp@@3VCWinApp@@A DB 0ccH DUP (?)			; theApp
_BSS	ENDS
;	COMDAT CRT$XCU
CRT$XCU	SEGMENT
_atlTraceException$initializer$ DD FLAT:??__EatlTraceException@ATL@@YAXXZ
CRT$XCU	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1NK@DHCIKOFO@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAa?$AAl?$AAe?$AAx?$AAa?$AAn?$AAd?$AAe?$AAr?$AA?5?$AAr?$AAi?$AAc?$AAc?$AAi?$AAo?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe@
CONST	SEGMENT
??_C@_1NK@DHCIKOFO@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAa?$AAl?$AAe?$AAx?$AAa?$AAn?$AAd?$AAe?$AAr?$AA?5?$AAr?$AAi?$AAc?$AAc?$AAi?$AAo?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H
	DB	's', 00H, '\', 00H, 'a', 00H, 'l', 00H, 'e', 00H, 'x', 00H, 'a'
	DB	00H, 'n', 00H, 'd', 00H, 'e', 00H, 'r', 00H, ' ', 00H, 'r', 00H
	DB	'i', 00H, 'c', 00H, 'c', 00H, 'i', 00H, 'o', 00H, '\', 00H, 'd'
	DB	00H, 'o', 00H, 'c', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H
	DB	't', 00H, 's', 00H, '\', 00H, 'v', 00H, 'i', 00H, 's', 00H, 'u'
	DB	00H, 'a', 00H, 'l', 00H, ' ', 00H, 's', 00H, 't', 00H, 'u', 00H
	DB	'd', 00H, 'i', 00H, 'o', 00H, ' ', 00H, '2', 00H, '0', 00H, '1'
	DB	00H, '3', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'j', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 's', 00H, '\', 00H, 'c', 00H, 's'
	DB	00H, 'i', 00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 'a', 00H
	DB	'r', 00H, 'r', 00H, 'a', 00H, 'y', 00H, '_', 00H, 't', 00H, 'e'
	DB	00H, 's', 00H, 't', 00H, '\', 00H, 'c', 00H, 's', 00H, 'i', 00H
	DB	'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, 'a', 00H, 'r', 00H, 'r'
	DB	00H, 'a', 00H, 'y', 00H, '_', 00H, 't', 00H, 'e', 00H, 's', 00H
	DB	't', 00H, '\', 00H, 't', 00H, 'e', 00H, 's', 00H, 't', 00H, '.'
	DB	00H, 'c', 00H, 'p', 00H, 'p', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1FE@OLJODHIP@?$AAF?$AAa?$AAt?$AAa?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAF?$AAC?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@
CONST	SEGMENT
??_C@_1FE@OLJODHIP@?$AAF?$AAa?$AAt?$AAa?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAF?$AAC?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@ DB 'F'
	DB	00H, 'a', 00H, 't', 00H, 'a', 00H, 'l', 00H, ' ', 00H, 'E', 00H
	DB	'r', 00H, 'r', 00H, 'o', 00H, 'r', 00H, ':', 00H, ' ', 00H, 'M'
	DB	00H, 'F', 00H, 'C', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'i', 00H
	DB	't', 00H, 'i', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'z', 00H, 'a'
	DB	00H, 't', 00H, 'i', 00H, 'o', 00H, 'n', 00H, ' ', 00H, 'f', 00H
	DB	'a', 00H, 'i', 00H, 'l', 00H, 'e', 00H, 'd', 00H, '!', 00H, 0dH
	DB	00H, 0aH, 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@EBFIOLIP@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?5?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@EBFIOLIP@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?5?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@ DB 'C'
	DB	00H, 'o', 00H, 'u', 00H, 'l', 00H, 'd', 00H, 'n', 00H, '''', 00H
	DB	't', 00H, ' ', 00H, 'g', 00H, 'e', 00H, 't', 00H, ' ', 00H, 'm'
	DB	00H, 'o', 00H, 'd', 00H, 'u', 00H, 'l', 00H, 'e', 00H, ' ', 00H
	DB	'h', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'l', 00H, 'e', 00H, '!'
	DB	00H, 0dH, 00H, 0aH, 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@ DB 'm'
	DB	00H, '_', 00H, 'p', 00H, 'D', 00H, 'a', 00H, 't', 00H, 'a', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 's', 00H, 'i', 00H, 'm', 00H, 'p', 00H, 'c', 00H, 'o'
	DB	00H, 'l', 00H, 'l', 00H, '.', 00H, 'h', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@ DB 'n'
	DB	00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H, 'x', 00H, ' ', 00H
	DB	'>', 00H, '=', 00H, ' ', 00H, '0', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, 'n', 00H, 'I', 00H, 'n', 00H, 'd', 00H, 'e', 00H
	DB	'x', 00H, ' ', 00H, '<', 00H, ' ', 00H, 'm', 00H, '_', 00H, 'n'
	DB	00H, 'S', 00H, 'i', 00H, 'z', 00H, 'e', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
CONST	SEGMENT
??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@ DB '_'
	DB	00H, '_', 00H, 'a', 00H, 't', 00H, 'l', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 'd', 00H, 'V', 00H, 'a', 00H, 'l', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@
CONST	SEGMENT
??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@ DB 'A'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'h', 00H, 'r', 00H, 'o', 00H
	DB	'w', 00H, ':', 00H, ' ', 00H, 'h', 00H, 'r', 00H, ' ', 00H, '='
	DB	00H, ' ', 00H, '0', 00H, 'x', 00H, '%', 00H, 'x', 00H, 0aH, 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
CONST	SEGMENT
??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@ DB 'c:\pr'
	DB	'ogram files (x86)\microsoft visual studio 12.0\vc\atlmfc\incl'
	DB	'ude\atlexcept.h', 00H			; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA DD 041H	; `ATL::AtlThrowImpl'::`2'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 't', 00H, 'r', 00H, 'a', 00H, 'c', 00H, 'e', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
CONST	SEGMENT
??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@ DB 'f'
	DB	00H, 'a', 00H, 'l', 00H, 's', 00H, 'e', 00H, ' ', 00H, '&', 00H
	DB	'&', 00H, ' ', 00H, '"', 00H, 'T', 00H, 'o', 00H, 'o', 00H, ' '
	DB	00H, 'm', 00H, 'a', 00H, 'n', 00H, 'y', 00H, ' ', 00H, 'c', 00H
	DB	'a', 00H, 't', 00H, 'e', 00H, 'g', 00H, 'o', 00H, 'r', 00H, 'i'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, 'd', 00H, 'e', 00H, 'f', 00H
	DB	'i', 00H, 'n', 00H, 'e', 00H, 'd', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
CONST	SEGMENT
??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@ DB '%', 00H, 'S', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H
	DB	'%', 00H, 's', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 'u'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
CONST	SEGMENT
??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@ DB '%', 00H, 's'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
CONST	SEGMENT
??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@ DB 'a'
	DB	00H, 't', 00H, 'l', 00H, 'T', 00H, 'r', 00H, 'a', 00H, 'c', 00H
	DB	'e', 00H, 'E', 00H, 'x', 00H, 'c', 00H, 'e', 00H, 'p', 00H, 't'
	DB	00H, 'i', 00H, 'o', 00H, 'n', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '2', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'a', 00H, 't', 00H, 'l', 00H, 'm', 00H
	DB	'f', 00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l'
	DB	00H, 'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 't', 00H
	DB	'l', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, '.'
	DB	00H, 'h', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@ DB '%', 00H, 's', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z$0
__ehfuncinfo$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z$0
__ehfuncinfo$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$_wmain DD 0ffffffffH
	DD	FLAT:__unwindfunclet$_wmain$0
	DD	00H
	DD	FLAT:__unwindfunclet$_wmain$1
__ehfuncinfo$_wmain DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$_wmain
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0
__ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
CRT$XCU	SEGMENT
_theApp$initializer$ DD FLAT:??__EtheApp@@YAXXZ
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAXPAXPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAXPAXPAH@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>, COMDAT

; 266  : 		void __cdecl operator delete(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 267  : 			_In_ void* /* pv */,
; 268  : 			_In_ _Ty* /* p */)
; 269  : 		{
; 270  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAXPAXPAH@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAPAXIPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAPAXIPAH@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>, COMDAT

; 259  : 		void * __cdecl operator new(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 260  : 			_In_ size_t,
; 261  : 			_In_ _Ty* p)
; 262  : 		{
; 263  : 			return p;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]

; 264  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAPAXIPAH@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__t$ = 8						; size = 4
??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@ABH@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper, COMDAT
; _this$ = ecx

; 256  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __t$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx

; 257  : 		}

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@ABH@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAXPAXPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAXPAXPAH@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>, COMDAT

; 278  : 		void __cdecl operator delete(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 279  : 			_In_ void* /* pv */,
; 280  : 			_In_ _Ty* /* p */)
; 281  : 		{
; 282  : 		}

  0001e	5f		 pop	 edi
  0001f	5e		 pop	 esi
  00020	5b		 pop	 ebx
  00021	8b e5		 mov	 esp, ebp
  00023	5d		 pop	 ebp
  00024	c3		 ret	 0
??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAXPAXPAH@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAPAXIPAH@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
_p$ = 12						; size = 4
??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAPAXIPAH@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>, COMDAT

; 271  : 		void * __cdecl operator new(

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 272  : 			_In_ size_t,
; 273  : 			_In_ _Ty* p)
; 274  : 		{
; 275  : 			return p;

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _p$[ebp]

; 276  : 		}

  00021	5f		 pop	 edi
  00022	5e		 pop	 esi
  00023	5b		 pop	 ebx
  00024	8b e5		 mov	 esp, ebp
  00026	5d		 pop	 ebp
  00027	c3		 ret	 0
??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAPAXIPAH@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@ABH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__t$ = 8						; size = 4
??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@ABH@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper, COMDAT
; _this$ = ecx

; 268  : 		{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR __t$[ebp]
  00029	8b 11		 mov	 edx, DWORD PTR [ecx]
  0002b	89 10		 mov	 DWORD PTR [eax], edx

; 269  : 		}

  0002d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00030	5f		 pop	 edi
  00031	5e		 pop	 esi
  00032	5b		 pop	 ebx
  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 04 00	 ret	 4
??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@ABH@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXI@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXI@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z
_TEXT	SEGMENT
tv80 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_nIndex$ = 8						; size = 4
_t$ = 12						; size = 4
?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex, COMDAT
; _this$ = ecx

; 278  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 279  : 		new(m_aT + nIndex) Wrapper(t);

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  0004a	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0004d	50		 push	 eax
  0004e	6a 04		 push	 4
  00050	e8 00 00 00 00	 call	 ??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAPAXIPAH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>
  00055	83 c4 08	 add	 esp, 8
  00058	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00065	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  0006c	74 17		 je	 SHORT $LN3@InternalSe
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00071	51		 push	 ecx
  00072	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00078	e8 00 00 00 00	 call	 ??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@ABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper
  0007d	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  00083	eb 0a		 jmp	 SHORT $LN4@InternalSe
$LN3@InternalSe:
  00085	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
$LN4@InternalSe:
  0008f	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  00095	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 280  : 	}

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000b	50		 push	 eax
  0000c	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@SAXPAXPAH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>
  00018	83 c4 08	 add	 esp, 8
  0001b	c3		 ret	 0
__ehhandler$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ?GetData@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?GetData@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QBEPAHXZ PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::GetData, COMDAT
; _this$ = ecx

; 221  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 222  : 		return m_aT;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 223  : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
?GetData@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QBEPAHXZ ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::GetData
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEAAHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEAAHH@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::operator[], COMDAT
; _this$ = ecx

; 208  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 209  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

  00023	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00027	7c 0b		 jl	 SHORT $LN5@operator
  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0002f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00032	7c 30		 jl	 SHORT $LN6@operator
$LN5@operator:
  00034	8b f4		 mov	 esi, esp
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00040	6a 00		 push	 0
  00042	68 d1 00 00 00	 push	 209			; 000000d1H
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1NK@DHCIKOFO@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAa?$AAl?$AAe?$AAx?$AAa?$AAn?$AAd?$AAe?$AAr?$AA?5?$AAr?$AAi?$AAc?$AAc?$AAi?$AAo?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe@
  0004c	6a 02		 push	 2
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN6@operator
  00063	cc		 int	 3
$LN6@operator:

; 210  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00064	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00068	7c 0b		 jl	 SHORT $LN1@operator
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00070	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00073	7c 0c		 jl	 SHORT $LN2@operator
$LN1@operator:

; 211  : 		{
; 212  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00075	6a 01		 push	 1
  00077	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0007c	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN2@operator:

; 213  : 		}
; 214  : 		return m_aT[nIndex];

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00089	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
$LN4@operator:

; 215  : 	}

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEAAHH@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXXZ PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::RemoveAll, COMDAT
; _this$ = ecx

; 179  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 180  : 		if(m_aT != NULL)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 40		 je	 SHORT $LN4@RemoveAll

; 181  : 		{
; 182  : 			for(int i = 0; i < m_nSize; i++)

  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN3@RemoveAll
$LN2@RemoveAll:
  00034	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN3@RemoveAll:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00043	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00046	7d 02		 jge	 SHORT $LN1@RemoveAll

; 183  : 				m_aT[i].~T();

  00048	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN1@RemoveAll:

; 184  : 			free(m_aT);

  0004a	8b f4		 mov	 esi, esp
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	51		 push	 ecx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00058	83 c4 04	 add	 esp, 4
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 185  : 			m_aT = NULL;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN4@RemoveAll:

; 186  : 		}
; 187  : 		m_nSize = 0;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 188  : 		m_nAllocSize = 0;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 189  :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXXZ ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z
_TEXT	SEGMENT
tv93 = -244						; size = 4
tv74 = -244						; size = 4
_nNewAllocSize$1 = -44					; size = 4
_aT$2 = -32						; size = 4
___atl_condVal$3 = -20					; size = 4
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add, COMDAT
; _this$ = ecx

; 122  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00013	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 123  : 		if(m_nSize == m_nAllocSize)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002f	0f 85 09 01 00
	00		 jne	 $LN11@Add
$LN10@Add:

; 124  : 		{
; 125  : 			// Make sure newElement is not a reference to an element in the array.
; 126  : 			// Or else, it will be invalidated by the reallocation.
; 127  : 			ATLENSURE(	(&t < m_aT) ||

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0003b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0003d	72 1f		 jb	 SHORT $LN14@Add
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0004d	39 45 08	 cmp	 DWORD PTR _t$[ebp], eax
  00050	73 0c		 jae	 SHORT $LN14@Add
  00052	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
  0005c	eb 0a		 jmp	 SHORT $LN15@Add
$LN14@Add:
  0005e	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
$LN15@Add:
  00068	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  0006e	89 4d ec	 mov	 DWORD PTR ___atl_condVal$3[ebp], ecx
$LN7@Add:

; 128  : 						(&t >= (m_aT + m_nAllocSize) ) );

  00071	83 7d ec 00	 cmp	 DWORD PTR ___atl_condVal$3[ebp], 0
  00075	75 30		 jne	 SHORT $LN6@Add
  00077	8b f4		 mov	 esi, esp
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00083	6a 00		 push	 0
  00085	68 80 00 00 00	 push	 128			; 00000080H
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_1NK@DHCIKOFO@?$AAc?$AA?3?$AA?2?$AAu?$AAs?$AAe?$AAr?$AAs?$AA?2?$AAa?$AAl?$AAe?$AAx?$AAa?$AAn?$AAd?$AAe?$AAr?$AA?5?$AAr?$AAi?$AAc?$AAc?$AAi?$AAo?$AA?2?$AAd?$AAo?$AAc?$AAu?$AAm?$AAe@
  0008f	6a 02		 push	 2
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00097	83 c4 18	 add	 esp, 24			; 00000018H
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	75 01		 jne	 SHORT $LN6@Add
  000a6	cc		 int	 3
$LN6@Add:
  000a7	33 c0		 xor	 eax, eax
  000a9	75 c6		 jne	 SHORT $LN7@Add
  000ab	83 7d ec 00	 cmp	 DWORD PTR ___atl_condVal$3[ebp], 0
  000af	75 0a		 jne	 SHORT $LN9@Add
  000b1	68 05 40 00 80	 push	 -2147467259		; 80004005H
  000b6	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN9@Add:
  000bb	33 c0		 xor	 eax, eax
  000bd	0f 85 72 ff ff
	ff		 jne	 $LN10@Add

; 129  : 
; 130  : 			T* aT;
; 131  : 			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000ca	75 0c		 jne	 SHORT $LN17@Add
  000cc	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv93[ebp], 1
  000d6	eb 0e		 jmp	 SHORT $LN18@Add
$LN17@Add:
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000de	d1 e2		 shl	 edx, 1
  000e0	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv93[ebp], edx
$LN18@Add:
  000e6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  000ec	89 45 d4	 mov	 DWORD PTR _nNewAllocSize$1[ebp], eax

; 132  : 
; 133  : 			if (nNewAllocSize<0||nNewAllocSize>INT_MAX/sizeof(T))

  000ef	83 7d d4 00	 cmp	 DWORD PTR _nNewAllocSize$1[ebp], 0
  000f3	7c 09		 jl	 SHORT $LN2@Add
  000f5	81 7d d4 ff ff
	ff 1f		 cmp	 DWORD PTR _nNewAllocSize$1[ebp], 536870911 ; 1fffffffH
  000fc	76 04		 jbe	 SHORT $LN3@Add
$LN2@Add:

; 134  : 			{
; 135  : 				return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 63		 jmp	 SHORT $LN13@Add
$LN3@Add:

; 136  : 			}
; 137  : 
; 138  : 			aT = (T*)_recalloc(m_aT, nNewAllocSize, sizeof(T));

  00102	8b f4		 mov	 esi, esp
  00104	6a 04		 push	 4
  00106	8b 45 d4	 mov	 eax, DWORD PTR _nNewAllocSize$1[ebp]
  00109	50		 push	 eax
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	52		 push	 edx
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___recalloc
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	89 45 e0	 mov	 DWORD PTR _aT$2[ebp], eax

; 139  : 			if(aT == NULL)

  00123	83 7d e0 00	 cmp	 DWORD PTR _aT$2[ebp], 0
  00127	75 04		 jne	 SHORT $LN1@Add

; 140  : 				return FALSE;

  00129	33 c0		 xor	 eax, eax
  0012b	eb 38		 jmp	 SHORT $LN13@Add
$LN1@Add:

; 141  : 			m_nAllocSize = nNewAllocSize;

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 4d d4	 mov	 ecx, DWORD PTR _nNewAllocSize$1[ebp]
  00133	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 142  : 			m_aT = aT;

  00136	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 4d e0	 mov	 ecx, DWORD PTR _aT$2[ebp]
  0013c	89 08		 mov	 DWORD PTR [eax], ecx
$LN11@Add:

; 143  : 		}
; 144  : 		InternalSetAtIndex(m_nSize, t);

  0013e	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00141	50		 push	 eax
  00142	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00148	52		 push	 edx
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex

; 145  : 		m_nSize++;

  00151	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00154	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00157	83 c1 01	 add	 ecx, 1
  0015a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0015d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 146  : 		return TRUE;

  00160	b8 01 00 00 00	 mov	 eax, 1
$LN13@Add:

; 147  : 	}

  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0016e	3b ec		 cmp	 ebp, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 04 00	 ret	 4
?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >, COMDAT
; _this$ = ecx

; 291  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 292  : 	RemoveAll();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXXZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::RemoveAll

; 293  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ PROC ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >, COMDAT
; _this$ = ecx

; 68   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 69   : 	}

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ENDP ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXI@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXI@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z
_TEXT	SEGMENT
tv80 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
_nIndex$ = 8						; size = 4
_t$ = 12						; size = 4
?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex, COMDAT
; _this$ = ecx

; 290  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec e8 00 00
	00		 sub	 esp, 232		; 000000e8H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	51		 push	 ecx
  0001b	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00021	b9 3a 00 00 00	 mov	 ecx, 58			; 0000003aH
  00026	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002b	f3 ab		 rep stosd
  0002d	59		 pop	 ecx
  0002e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00033	33 c5		 xor	 eax, ebp
  00035	50		 push	 eax
  00036	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  00039	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax
  0003f	89 4d ec	 mov	 DWORD PTR _this$[ebp], ecx

; 291  : 		new(m_aT + nIndex) Wrapper(t);

  00042	8b 45 ec	 mov	 eax, DWORD PTR _this$[ebp]
  00045	8b 08		 mov	 ecx, DWORD PTR [eax]
  00047	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  0004a	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
  0004d	50		 push	 eax
  0004e	6a 04		 push	 4
  00050	e8 00 00 00 00	 call	 ??$?2H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAPAXIPAH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator new<int>
  00055	83 c4 08	 add	 esp, 8
  00058	89 85 20 ff ff
	ff		 mov	 DWORD PTR $T3[ebp], eax
  0005e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0
  00065	83 bd 20 ff ff
	ff 00		 cmp	 DWORD PTR $T3[ebp], 0
  0006c	74 17		 je	 SHORT $LN3@InternalSe
  0006e	8b 4d 0c	 mov	 ecx, DWORD PTR _t$[ebp]
  00071	51		 push	 ecx
  00072	8b 8d 20 ff ff
	ff		 mov	 ecx, DWORD PTR $T3[ebp]
  00078	e8 00 00 00 00	 call	 ??0Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@ABH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::Wrapper
  0007d	89 85 0c ff ff
	ff		 mov	 DWORD PTR tv80[ebp], eax
  00083	eb 0a		 jmp	 SHORT $LN4@InternalSe
$LN3@InternalSe:
  00085	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv80[ebp], 0
$LN4@InternalSe:
  0008f	8b 95 0c ff ff
	ff		 mov	 edx, DWORD PTR tv80[ebp]
  00095	89 95 14 ff ff
	ff		 mov	 DWORD PTR $T2[ebp], edx
  0009b	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1

; 292  : 	}

  000a2	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  000a5	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  000ac	59		 pop	 ecx
  000ad	5f		 pop	 edi
  000ae	5e		 pop	 esi
  000af	5b		 pop	 ebx
  000b0	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  000b6	3b ec		 cmp	 ebp, esp
  000b8	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000bd	8b e5		 mov	 esp, ebp
  000bf	5d		 pop	 ebp
  000c0	c2 08 00	 ret	 8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z$0:
  00000	8b 4d ec	 mov	 ecx, DWORD PTR _this$[ebp]
  00003	8b 09		 mov	 ecx, DWORD PTR [ecx]
  00005	8b 45 08	 mov	 eax, DWORD PTR _nIndex$[ebp]
  00008	8d 04 81	 lea	 eax, DWORD PTR [ecx+eax*4]
  0000b	50		 push	 eax
  0000c	8b 85 20 ff ff
	ff		 mov	 eax, DWORD PTR $T3[ebp]
  00012	50		 push	 eax
  00013	e8 00 00 00 00	 call	 ??$?3H@Wrapper@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@SAXPAXPAH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Wrapper::operator delete<int>
  00018	83 c4 08	 add	 esp, 8
  0001b	c3		 ret	 0
__ehhandler$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z:
  0001c	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00020	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00023	8b 8a 08 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-248]
  00029	33 c8		 xor	 ecx, eax
  0002b	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00030	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z
  00035	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEAAHH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nIndex$ = 8						; size = 4
??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEAAHH@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::operator[], COMDAT
; _this$ = ecx

; 230  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 231  : 		ATLASSERT(nIndex >= 0 && nIndex < m_nSize);

  00023	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00027	7c 0b		 jl	 SHORT $LN5@operator
  00029	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002c	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  0002f	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00032	7c 30		 jl	 SHORT $LN6@operator
$LN5@operator:
  00034	8b f4		 mov	 esi, esp
  00036	68 00 00 00 00	 push	 OFFSET ??_C@_1EA@JHMKKLFC@?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DO?$AA?$DN?$AA?5?$AA0?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AAn?$AAI?$AAn?$AAd?$AAe?$AAx?$AA?5?$AA?$DM?$AA?5?$AAm?$AA_?$AAn?$AAS?$AAi?$AAz?$AAe?$AA?$AA@
  0003b	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00040	6a 00		 push	 0
  00042	68 e7 00 00 00	 push	 231			; 000000e7H
  00047	68 00 00 00 00	 push	 OFFSET ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0004c	6a 02		 push	 2
  0004e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00054	83 c4 18	 add	 esp, 24			; 00000018H
  00057	3b f4		 cmp	 esi, esp
  00059	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005e	83 f8 01	 cmp	 eax, 1
  00061	75 01		 jne	 SHORT $LN6@operator
  00063	cc		 int	 3
$LN6@operator:

; 232  : 		if(nIndex < 0 || nIndex >= m_nSize)

  00064	83 7d 08 00	 cmp	 DWORD PTR _nIndex$[ebp], 0
  00068	7c 0b		 jl	 SHORT $LN1@operator
  0006a	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006d	8b 4d 08	 mov	 ecx, DWORD PTR _nIndex$[ebp]
  00070	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00073	7c 0c		 jl	 SHORT $LN2@operator
$LN1@operator:

; 233  : 		{
; 234  : 			_AtlRaiseException((DWORD)EXCEPTION_ARRAY_BOUNDS_EXCEEDED);

  00075	6a 01		 push	 1
  00077	68 8c 00 00 c0	 push	 -1073741684		; c000008cH
  0007c	e8 00 00 00 00	 call	 ?_AtlRaiseException@ATL@@YAXKK@Z ; ATL::_AtlRaiseException
$LN2@operator:

; 235  : 		}
; 236  : 		return m_aT[nIndex];

  00081	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00084	8b 08		 mov	 ecx, DWORD PTR [eax]
  00086	8b 55 08	 mov	 edx, DWORD PTR _nIndex$[ebp]
  00089	8d 04 91	 lea	 eax, DWORD PTR [ecx+edx*4]
$LN4@operator:

; 237  : 	}

  0008c	5f		 pop	 edi
  0008d	5e		 pop	 esi
  0008e	5b		 pop	 ebx
  0008f	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00095	3b ec		 cmp	 ebp, esp
  00097	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0009c	8b e5		 mov	 esp, ebp
  0009e	5d		 pop	 ebp
  0009f	c2 04 00	 ret	 4
??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEAAHH@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::operator[]
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_i$1 = -20						; size = 4
_this$ = -8						; size = 4
?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXXZ PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::RemoveAll, COMDAT
; _this$ = ecx

; 209  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d8 00 00
	00		 sub	 esp, 216		; 000000d8H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 28 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-216]
  00013	b9 36 00 00 00	 mov	 ecx, 54			; 00000036H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 210  : 		if(m_aT != NULL)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 40		 je	 SHORT $LN4@RemoveAll

; 211  : 		{
; 212  : 			for(int i = 0; i < m_nSize; i++)

  0002b	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00032	eb 09		 jmp	 SHORT $LN3@RemoveAll
$LN2@RemoveAll:
  00034	8b 45 ec	 mov	 eax, DWORD PTR _i$1[ebp]
  00037	83 c0 01	 add	 eax, 1
  0003a	89 45 ec	 mov	 DWORD PTR _i$1[ebp], eax
$LN3@RemoveAll:
  0003d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00040	8b 4d ec	 mov	 ecx, DWORD PTR _i$1[ebp]
  00043	3b 48 04	 cmp	 ecx, DWORD PTR [eax+4]
  00046	7d 02		 jge	 SHORT $LN1@RemoveAll

; 213  : 				m_aT[i].~T();

  00048	eb ea		 jmp	 SHORT $LN2@RemoveAll
$LN1@RemoveAll:

; 214  : 			free(m_aT);

  0004a	8b f4		 mov	 esi, esp
  0004c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0004f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00051	51		 push	 ecx
  00052	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00058	83 c4 04	 add	 esp, 4
  0005b	3b f4		 cmp	 esi, esp
  0005d	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 215  : 			m_aT = NULL;

  00062	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00065	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
$LN4@RemoveAll:

; 216  : 		}
; 217  : 		m_nSize = 0;

  0006b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 218  : 		m_nAllocSize = 0;

  00075	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00078	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 219  :     }

  0007f	5f		 pop	 edi
  00080	5e		 pop	 esi
  00081	5b		 pop	 ebx
  00082	81 c4 d8 00 00
	00		 add	 esp, 216		; 000000d8H
  00088	3b ec		 cmp	 ebp, esp
  0008a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008f	8b e5		 mov	 esp, ebp
  00091	5d		 pop	 ebp
  00092	c3		 ret	 0
?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::RemoveAll
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEHABH@Z
_TEXT	SEGMENT
tv93 = -244						; size = 4
tv74 = -244						; size = 4
_nNewAllocSize$1 = -44					; size = 4
_aT$2 = -32						; size = 4
___atl_condVal$3 = -20					; size = 4
_this$ = -8						; size = 4
_t$ = 8							; size = 4
?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEHABH@Z PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Add, COMDAT
; _this$ = ecx

; 164  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec f4 00 00
	00		 sub	 esp, 244		; 000000f4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 0c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-244]
  00013	b9 3d 00 00 00	 mov	 ecx, 61			; 0000003dH
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 165  : 		if(m_nSize == m_nAllocSize)

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00029	8b 50 04	 mov	 edx, DWORD PTR [eax+4]
  0002c	3b 51 08	 cmp	 edx, DWORD PTR [ecx+8]
  0002f	0f 85 09 01 00
	00		 jne	 $LN11@Add
$LN10@Add:

; 166  : 		{
; 167  : 			// Make sure newElement is not a reference to an element in the array.
; 168  : 			// Or else, it will be invalidated by the reallocation.
; 169  : 			ATLENSURE(	(&t < m_aT) ||

  00035	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _t$[ebp]
  0003b	3b 08		 cmp	 ecx, DWORD PTR [eax]
  0003d	72 1f		 jb	 SHORT $LN14@Add
  0003f	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  00042	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  00045	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00048	8b 11		 mov	 edx, DWORD PTR [ecx]
  0004a	8d 04 82	 lea	 eax, DWORD PTR [edx+eax*4]
  0004d	39 45 08	 cmp	 DWORD PTR _t$[ebp], eax
  00050	73 0c		 jae	 SHORT $LN14@Add
  00052	c7 85 0c ff ff
	ff 00 00 00 00	 mov	 DWORD PTR tv74[ebp], 0
  0005c	eb 0a		 jmp	 SHORT $LN15@Add
$LN14@Add:
  0005e	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv74[ebp], 1
$LN15@Add:
  00068	8b 8d 0c ff ff
	ff		 mov	 ecx, DWORD PTR tv74[ebp]
  0006e	89 4d ec	 mov	 DWORD PTR ___atl_condVal$3[ebp], ecx
$LN7@Add:

; 170  : 						(&t >= (m_aT + m_nAllocSize) ) );

  00071	83 7d ec 00	 cmp	 DWORD PTR ___atl_condVal$3[ebp], 0
  00075	75 30		 jne	 SHORT $LN6@Add
  00077	8b f4		 mov	 esi, esp
  00079	68 00 00 00 00	 push	 OFFSET ??_C@_1BM@GBBOFEAE@?$AA_?$AA_?$AAa?$AAt?$AAl?$AA_?$AAc?$AAo?$AAn?$AAd?$AAV?$AAa?$AAl?$AA?$AA@
  0007e	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00083	6a 00		 push	 0
  00085	68 aa 00 00 00	 push	 170			; 000000aaH
  0008a	68 00 00 00 00	 push	 OFFSET ??_C@_1KI@KJKLFHG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0008f	6a 02		 push	 2
  00091	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00097	83 c4 18	 add	 esp, 24			; 00000018H
  0009a	3b f4		 cmp	 esi, esp
  0009c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000a1	83 f8 01	 cmp	 eax, 1
  000a4	75 01		 jne	 SHORT $LN6@Add
  000a6	cc		 int	 3
$LN6@Add:
  000a7	33 c0		 xor	 eax, eax
  000a9	75 c6		 jne	 SHORT $LN7@Add
  000ab	83 7d ec 00	 cmp	 DWORD PTR ___atl_condVal$3[ebp], 0
  000af	75 0a		 jne	 SHORT $LN9@Add
  000b1	68 05 40 00 80	 push	 -2147467259		; 80004005H
  000b6	e8 00 00 00 00	 call	 ?AtlThrowImpl@ATL@@YGXJ@Z ; ATL::AtlThrowImpl
$LN9@Add:
  000bb	33 c0		 xor	 eax, eax
  000bd	0f 85 72 ff ff
	ff		 jne	 $LN10@Add

; 171  : 
; 172  : 			T* aT;
; 173  : 			int nNewAllocSize = (m_nAllocSize == 0) ? 1 : (m_nSize * 2);

  000c3	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  000c6	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  000ca	75 0c		 jne	 SHORT $LN17@Add
  000cc	c7 85 0c ff ff
	ff 01 00 00 00	 mov	 DWORD PTR tv93[ebp], 1
  000d6	eb 0e		 jmp	 SHORT $LN18@Add
$LN17@Add:
  000d8	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  000db	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000de	d1 e2		 shl	 edx, 1
  000e0	89 95 0c ff ff
	ff		 mov	 DWORD PTR tv93[ebp], edx
$LN18@Add:
  000e6	8b 85 0c ff ff
	ff		 mov	 eax, DWORD PTR tv93[ebp]
  000ec	89 45 d4	 mov	 DWORD PTR _nNewAllocSize$1[ebp], eax

; 174  : 
; 175  : 			if (nNewAllocSize<0||nNewAllocSize>INT_MAX/sizeof(T))

  000ef	83 7d d4 00	 cmp	 DWORD PTR _nNewAllocSize$1[ebp], 0
  000f3	7c 09		 jl	 SHORT $LN2@Add
  000f5	81 7d d4 ff ff
	ff 1f		 cmp	 DWORD PTR _nNewAllocSize$1[ebp], 536870911 ; 1fffffffH
  000fc	76 04		 jbe	 SHORT $LN3@Add
$LN2@Add:

; 176  : 			{
; 177  : 				return FALSE;

  000fe	33 c0		 xor	 eax, eax
  00100	eb 63		 jmp	 SHORT $LN13@Add
$LN3@Add:

; 178  : 			}
; 179  : 
; 180  : 			aT = (T*)_recalloc(m_aT, nNewAllocSize, sizeof(T));

  00102	8b f4		 mov	 esi, esp
  00104	6a 04		 push	 4
  00106	8b 45 d4	 mov	 eax, DWORD PTR _nNewAllocSize$1[ebp]
  00109	50		 push	 eax
  0010a	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0010d	8b 11		 mov	 edx, DWORD PTR [ecx]
  0010f	52		 push	 edx
  00110	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___recalloc
  00116	83 c4 0c	 add	 esp, 12			; 0000000cH
  00119	3b f4		 cmp	 esi, esp
  0011b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00120	89 45 e0	 mov	 DWORD PTR _aT$2[ebp], eax

; 181  : 			if(aT == NULL)

  00123	83 7d e0 00	 cmp	 DWORD PTR _aT$2[ebp], 0
  00127	75 04		 jne	 SHORT $LN1@Add

; 182  : 				return FALSE;

  00129	33 c0		 xor	 eax, eax
  0012b	eb 38		 jmp	 SHORT $LN13@Add
$LN1@Add:

; 183  : 			m_nAllocSize = nNewAllocSize;

  0012d	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00130	8b 4d d4	 mov	 ecx, DWORD PTR _nNewAllocSize$1[ebp]
  00133	89 48 08	 mov	 DWORD PTR [eax+8], ecx

; 184  : 			m_aT = aT;

  00136	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00139	8b 4d e0	 mov	 ecx, DWORD PTR _aT$2[ebp]
  0013c	89 08		 mov	 DWORD PTR [eax], ecx
$LN11@Add:

; 185  : 		}
; 186  : 		InternalSetAtIndex(m_nSize, t);

  0013e	8b 45 08	 mov	 eax, DWORD PTR _t$[ebp]
  00141	50		 push	 eax
  00142	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00145	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00148	52		 push	 edx
  00149	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0014c	e8 00 00 00 00	 call	 ?InternalSetAtIndex@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXHABH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::InternalSetAtIndex

; 187  : 		m_nSize++;

  00151	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00154	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00157	83 c1 01	 add	 ecx, 1
  0015a	8b 55 f8	 mov	 edx, DWORD PTR _this$[ebp]
  0015d	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 188  : 		return TRUE;

  00160	b8 01 00 00 00	 mov	 eax, 1
$LN13@Add:

; 189  : 	}

  00165	5f		 pop	 edi
  00166	5e		 pop	 esi
  00167	5b		 pop	 ebx
  00168	81 c4 f4 00 00
	00		 add	 esp, 244		; 000000f4H
  0016e	3b ec		 cmp	 ebp, esp
  00170	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00175	8b e5		 mov	 esp, ebp
  00177	5d		 pop	 ebp
  00178	c2 04 00	 ret	 4
?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEHABH@Z ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Add
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >, COMDAT
; _this$ = ecx

; 303  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 304  : 	RemoveAll();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::RemoveAll

; 305  : }

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlsimpcoll.h
;	COMDAT ??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ PROC ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >, COMDAT
; _this$ = ecx

; 120  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0
  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
  00036	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00039	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 121  : 	}

  00040	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00043	5f		 pop	 edi
  00044	5e		 pop	 esi
  00045	5b		 pop	 ebx
  00046	8b e5		 mov	 esp, ebp
  00048	5d		 pop	 ebp
  00049	c3		 ret	 0
??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT _wmain
_TEXT	SEGMENT
$T2 = -400						; size = 4
$T3 = -388						; size = 4
$T4 = -376						; size = 4
$T5 = -364						; size = 4
$T6 = -352						; size = 4
$T7 = -340						; size = 4
_i$ = -136						; size = 4
_h$ = -124						; size = 4
_e$ = -112						; size = 4
_f$ = -100						; size = 4
_d$ = -88						; size = 12
_c$ = -68						; size = 4
_b$ = -56						; size = 12
_nRetCode$ = -36					; size = 4
_hModule$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_envp$ = 16						; size = 4
_wmain	PROC						; COMDAT

; 313  : int wmain( int argc, _In_reads_( argc ) _Readable_elements_( argc ) WCHAR* argv[ ], WCHAR* envp[ ] ) {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$_wmain
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec 88 01 00
	00		 sub	 esp, 392		; 00000188H
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 6c fe ff
	ff		 lea	 edi, DWORD PTR [ebp-404]
  00020	b9 62 00 00 00	 mov	 ecx, 98			; 00000062H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 314  : 	//printf( "start!\r\n" );
; 315  : 	HMODULE hModule = ::GetModuleHandleW( NULL );

  00040	8b f4		 mov	 esi, esp
  00042	6a 00		 push	 0
  00044	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetModuleHandleW@4
  0004a	3b f4		 cmp	 esi, esp
  0004c	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00051	89 45 e8	 mov	 DWORD PTR _hModule$[ebp], eax

; 316  : 	int nRetCode = 0;

  00054	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _nRetCode$[ebp], 0

; 317  : 
; 318  : 	if ( hModule == NULL ) {

  0005b	83 7d e8 00	 cmp	 DWORD PTR _hModule$[ebp], 0
  0005f	75 3a		 jne	 SHORT $LN2@wmain

; 319  : 		fwprintf( stderr, L"Couldn't get module handle!\r\n" );

  00061	8b f4		 mov	 esi, esp
  00063	68 00 00 00 00	 push	 OFFSET ??_C@_1DM@EBFIOLIP@?$AAC?$AAo?$AAu?$AAl?$AAd?$AAn?$AA?8?$AAt?$AA?5?$AAg?$AAe?$AAt?$AA?5?$AAm?$AAo?$AAd?$AAu?$AAl?$AAe?$AA?5?$AAh?$AAa?$AAn?$AAd?$AAl?$AAe?$AA?$CB?$AA?$AN?$AA?6?$AA?$AA@
  00068	8b fc		 mov	 edi, esp
  0006a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  00070	3b fc		 cmp	 edi, esp
  00072	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00077	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  0007c	d1 e1		 shl	 ecx, 1
  0007e	03 c1		 add	 eax, ecx
  00080	50		 push	 eax
  00081	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwprintf
  00087	83 c4 08	 add	 esp, 8
  0008a	3b f4		 cmp	 esi, esp
  0008c	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 320  : 		return ERROR_MOD_NOT_FOUND;

  00091	b8 7e 00 00 00	 mov	 eax, 126		; 0000007eH
  00096	e9 8d 01 00 00	 jmp	 $LN3@wmain
$LN2@wmain:

; 321  : 		}
; 322  : 
; 323  : 	if ( !AfxWinInit( hModule, NULL, ::GetCommandLine( ), 0 ) ) {

  0009b	6a 00		 push	 0
  0009d	8b f4		 mov	 esi, esp
  0009f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__GetCommandLineW@0
  000a5	3b f4		 cmp	 esi, esp
  000a7	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ac	50		 push	 eax
  000ad	6a 00		 push	 0
  000af	8b 45 e8	 mov	 eax, DWORD PTR _hModule$[ebp]
  000b2	50		 push	 eax
  000b3	e8 00 00 00 00	 call	 ?AfxWinInit@@YGHPAUHINSTANCE__@@0PA_WH@Z ; AfxWinInit
  000b8	85 c0		 test	 eax, eax
  000ba	75 3a		 jne	 SHORT $LN1@wmain

; 324  : 		fwprintf( stderr, L"Fatal Error: MFC initialization failed!\r\n" );

  000bc	8b f4		 mov	 esi, esp
  000be	68 00 00 00 00	 push	 OFFSET ??_C@_1FE@OLJODHIP@?$AAF?$AAa?$AAt?$AAa?$AAl?$AA?5?$AAE?$AAr?$AAr?$AAo?$AAr?$AA?3?$AA?5?$AAM?$AAF?$AAC?$AA?5?$AAi?$AAn?$AAi?$AAt?$AAi?$AAa?$AAl?$AAi?$AAz?$AAa?$AAt?$AAi?$AAo?$AAn?$AA?5@
  000c3	8b fc		 mov	 edi, esp
  000c5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp____iob_func
  000cb	3b fc		 cmp	 edi, esp
  000cd	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000d2	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000d7	d1 e1		 shl	 ecx, 1
  000d9	03 c1		 add	 eax, ecx
  000db	50		 push	 eax
  000dc	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwprintf
  000e2	83 c4 08	 add	 esp, 8
  000e5	3b f4		 cmp	 esi, esp
  000e7	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 325  : 		return ERROR_APP_INIT_FAILURE;

  000ec	b8 3f 02 00 00	 mov	 eax, 575		; 0000023fH
  000f1	e9 32 01 00 00	 jmp	 $LN3@wmain
$LN1@wmain:

; 326  : 		}
; 327  : 
; 328  : 
; 329  : 	ATL::CSimpleArray<int> b;

  000f6	6a 0c		 push	 12			; 0000000cH
  000f8	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  000fb	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXI@Z
  00100	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  00103	e8 00 00 00 00	 call	 ??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
  00108	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 330  : 
; 331  : 	//for ( size_t i = 0; i < SIZE_T_MAX; ++i ) {
; 332  : 	//	VERIFY( b.Add( 5 ) );
; 333  : 	//	}
; 334  : 
; 335  : 	b.Add( 5 );

  0010f	c7 85 70 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR $T2[ebp], 5
  00119	8d 85 70 fe ff
	ff		 lea	 eax, DWORD PTR $T2[ebp]
  0011f	50		 push	 eax
  00120	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  00123	e8 00 00 00 00	 call	 ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEHABH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::Add

; 336  : 
; 337  : 	b.RemoveAll( );

  00128	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  0012b	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEXXZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::RemoveAll

; 338  : 	//With SAL, /analyze will NOT catch this
; 339  : 	const auto c = b[ 2 ];

  00130	6a 02		 push	 2
  00132	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  00135	e8 00 00 00 00	 call	 ??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAEAAHH@Z ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::operator[]
  0013a	8b 00		 mov	 eax, DWORD PTR [eax]
  0013c	89 45 bc	 mov	 DWORD PTR _c$[ebp], eax

; 340  : 
; 341  : 	myATL::CSimpleArray<int> d;

  0013f	6a 0c		 push	 12			; 0000000cH
  00141	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  00144	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXI@Z
  00149	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  0014c	e8 00 00 00 00	 call	 ??0?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
  00151	c6 45 fc 01	 mov	 BYTE PTR __$EHRec$[ebp+8], 1

; 342  : 	
; 343  : 	const auto f = d[ 20 ];

  00155	6a 14		 push	 20			; 00000014H
  00157	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  0015a	e8 00 00 00 00	 call	 ??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEAAHH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::operator[]
  0015f	8b 00		 mov	 eax, DWORD PTR [eax]
  00161	89 45 9c	 mov	 DWORD PTR _f$[ebp], eax

; 344  : 
; 345  : 	d.Add( 5 );

  00164	c7 85 7c fe ff
	ff 05 00 00 00	 mov	 DWORD PTR $T3[ebp], 5
  0016e	8d 85 7c fe ff
	ff		 lea	 eax, DWORD PTR $T3[ebp]
  00174	50		 push	 eax
  00175	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  00178	e8 00 00 00 00	 call	 ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add

; 346  : 	d.RemoveAll( );

  0017d	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  00180	e8 00 00 00 00	 call	 ?RemoveAll@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEXXZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::RemoveAll

; 347  : 	
; 348  : 	//With SAL, /analyze will catch this
; 349  : 	const auto e = d[ 20 ];

  00185	6a 14		 push	 20			; 00000014H
  00187	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  0018a	e8 00 00 00 00	 call	 ??A?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEAAHH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::operator[]
  0018f	8b 00		 mov	 eax, DWORD PTR [eax]
  00191	89 45 90	 mov	 DWORD PTR _e$[ebp], eax

; 350  : 
; 351  : 	d.Add( 5 );

  00194	c7 85 88 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR $T4[ebp], 5
  0019e	8d 85 88 fe ff
	ff		 lea	 eax, DWORD PTR $T4[ebp]
  001a4	50		 push	 eax
  001a5	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  001a8	e8 00 00 00 00	 call	 ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add

; 352  : 	d.Add( 5 );

  001ad	c7 85 94 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR $T5[ebp], 5
  001b7	8d 85 94 fe ff
	ff		 lea	 eax, DWORD PTR $T5[ebp]
  001bd	50		 push	 eax
  001be	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  001c1	e8 00 00 00 00	 call	 ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add

; 353  : 	d.Add( 5 );

  001c6	c7 85 a0 fe ff
	ff 05 00 00 00	 mov	 DWORD PTR $T6[ebp], 5
  001d0	8d 85 a0 fe ff
	ff		 lea	 eax, DWORD PTR $T6[ebp]
  001d6	50		 push	 eax
  001d7	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  001da	e8 00 00 00 00	 call	 ?Add@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAEHABH@Z ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::Add

; 354  : 
; 355  : 	//const auto g = d[ d.GetSize( ) ];
; 356  : 
; 357  : 	const auto h = d.GetData( );

  001df	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  001e2	e8 00 00 00 00	 call	 ?GetData@?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QBEPAHXZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::GetData
  001e7	89 45 84	 mov	 DWORD PTR _h$[ebp], eax

; 358  : 	const auto i = h[ 3 ];

  001ea	b8 04 00 00 00	 mov	 eax, 4
  001ef	6b c8 03	 imul	 ecx, eax, 3
  001f2	8b 55 84	 mov	 edx, DWORD PTR _h$[ebp]
  001f5	8b 04 0a	 mov	 eax, DWORD PTR [edx+ecx]
  001f8	89 85 78 ff ff
	ff		 mov	 DWORD PTR _i$[ebp], eax

; 359  : 
; 360  : 	return nRetCode;

  001fe	8b 45 dc	 mov	 eax, DWORD PTR _nRetCode$[ebp]
  00201	89 85 ac fe ff
	ff		 mov	 DWORD PTR $T7[ebp], eax
  00207	c6 45 fc 00	 mov	 BYTE PTR __$EHRec$[ebp+8], 0
  0020b	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  0020e	e8 00 00 00 00	 call	 ??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
  00213	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0021a	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  0021d	e8 00 00 00 00	 call	 ??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
  00222	8b 85 ac fe ff
	ff		 mov	 eax, DWORD PTR $T7[ebp]
$LN3@wmain:

; 361  : 	}

  00228	52		 push	 edx
  00229	8b cd		 mov	 ecx, ebp
  0022b	50		 push	 eax
  0022c	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN11@wmain
  00232	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00237	58		 pop	 eax
  00238	5a		 pop	 edx
  00239	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  0023c	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00243	59		 pop	 ecx
  00244	5f		 pop	 edi
  00245	5e		 pop	 esi
  00246	5b		 pop	 ebx
  00247	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0024a	33 cd		 xor	 ecx, ebp
  0024c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00251	81 c4 94 01 00
	00		 add	 esp, 404		; 00000194H
  00257	3b ec		 cmp	 ebp, esp
  00259	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0025e	8b e5		 mov	 esp, ebp
  00260	5d		 pop	 ebp
  00261	c3		 ret	 0
  00262	8b ff		 npad	 2
$LN11@wmain:
  00264	02 00 00 00	 DD	 2
  00268	00 00 00 00	 DD	 $LN10@wmain
$LN10@wmain:
  0026c	c8 ff ff ff	 DD	 -56			; ffffffc8H
  00270	0c 00 00 00	 DD	 12			; 0000000cH
  00274	00 00 00 00	 DD	 $LN7@wmain
  00278	a8 ff ff ff	 DD	 -88			; ffffffa8H
  0027c	0c 00 00 00	 DD	 12			; 0000000cH
  00280	00 00 00 00	 DD	 $LN8@wmain
$LN8@wmain:
  00284	64		 DB	 100			; 00000064H
  00285	00		 DB	 0
$LN7@wmain:
  00286	62		 DB	 98			; 00000062H
  00287	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$_wmain$0:
  00000	8d 4d c8	 lea	 ecx, DWORD PTR _b$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@ATL@@@ATL@@QAE@XZ ; ATL::CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,ATL::CSimpleArrayEqualHelper<int> >
__unwindfunclet$_wmain$1:
  00008	8d 4d a8	 lea	 ecx, DWORD PTR _d$[ebp]
  0000b	e9 00 00 00 00	 jmp	 ??1?$CSimpleArray@HV?$CSimpleArrayEqualHelper@H@myATL@@@myATL@@QAE@XZ ; myATL::CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >::~CSimpleArray<int,myATL::CSimpleArrayEqualHelper<int> >
__ehhandler$_wmain:
  00010	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  00014	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  00017	8b 8a 68 fe ff
	ff		 mov	 ecx, DWORD PTR [edx-408]
  0001d	33 c8		 xor	 ecx, eax
  0001f	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00024	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  00027	33 c8		 xor	 ecx, eax
  00029	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0002e	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$_wmain
  00033	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
_wmain	ENDP
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__FtheApp@@YAXXZ
text$yd	SEGMENT
??__FtheApp@@YAXXZ PROC					; `dynamic atexit destructor for 'theApp'', COMDAT
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	b9 00 00 00 00	 mov	 ecx, OFFSET ?theApp@@3VCWinApp@@A ; theApp
  00023	e8 00 00 00 00	 call	 ??1CWinApp@@UAE@XZ	; CWinApp::~CWinApp
  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00031	3b ec		 cmp	 ebp, esp
  00033	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00038	8b e5		 mov	 esp, ebp
  0003a	5d		 pop	 ebp
  0003b	c3		 ret	 0
??__FtheApp@@YAXXZ ENDP					; `dynamic atexit destructor for 'theApp''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\users\alexander riccio\documents\visual studio 2013\projects\csimplearray_test\csimplearray_test\test.cpp
;	COMDAT ??__EtheApp@@YAXXZ
text$di	SEGMENT
??__EtheApp@@YAXXZ PROC					; `dynamic initializer for 'theApp'', COMDAT

; 311  : CWinApp theApp;

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 cc 00 00 00	 push	 204			; 000000ccH
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?theApp@@3VCWinApp@@A ; theApp
  00028	e8 00 00 00 00	 call	 ?__autoclassinit2@CWinApp@@QAEXI@Z
  0002d	6a 00		 push	 0
  0002f	b9 00 00 00 00	 mov	 ecx, OFFSET ?theApp@@3VCWinApp@@A ; theApp
  00034	e8 00 00 00 00	 call	 ??0CWinApp@@QAE@PB_W@Z	; CWinApp::CWinApp
  00039	68 00 00 00 00	 push	 OFFSET ??__FtheApp@@YAXXZ ; `dynamic atexit destructor for 'theApp''
  0003e	e8 00 00 00 00	 call	 _atexit
  00043	83 c4 04	 add	 esp, 4
  00046	5f		 pop	 edi
  00047	5e		 pop	 esi
  00048	5b		 pop	 ebx
  00049	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0004f	3b ec		 cmp	 ebp, esp
  00051	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00056	8b e5		 mov	 esp, ebp
  00058	5d		 pop	 ebp
  00059	c3		 ret	 0
??__EtheApp@@YAXXZ ENDP					; `dynamic initializer for 'theApp''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@CWinApp@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@CWinApp@@QAEXI@Z PROC			; CWinApp::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?__autoclassinit2@CWinApp@@QAEXI@Z ENDP			; CWinApp::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?AtlThrowImpl@ATL@@YGXJ@Z
_TEXT	SEGMENT
$T1 = -204						; size = 8
_hr$ = 8						; size = 4
?AtlThrowImpl@ATL@@YGXJ@Z PROC				; ATL::AtlThrowImpl, COMDAT

; 65   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 66   : 	ATLTRACE(atlTraceException, 0, _T("AtlThrow: hr = 0x%x\n"), hr );

  0001e	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  00021	50		 push	 eax
  00022	68 00 00 00 00	 push	 OFFSET ??_C@_1CK@DFMKPFAK@?$AAA?$AAt?$AAl?$AAT?$AAh?$AAr?$AAo?$AAw?$AA?3?$AA?5?$AAh?$AAr?$AA?5?$AA?$DN?$AA?5?$AA0?$AAx?$AA?$CF?$AAx?$AA?6?$AA?$AA@
  00027	6a 00		 push	 0
  00029	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  0002e	e8 00 00 00 00	 call	 ??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ ; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
  00033	50		 push	 eax
  00034	8b 0d 00 00 00
	00		 mov	 ecx, DWORD PTR ?__LINE__Var@?1??AtlThrowImpl@ATL@@YGXJ@Z@4JA
  0003a	83 c1 01	 add	 ecx, 1
  0003d	51		 push	 ecx
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_0FC@OFGMOGKO@c?3?2program?5files?5?$CIx86?$CJ?2microsoft@
  00043	8d 8d 34 ff ff
	ff		 lea	 ecx, DWORD PTR $T1[ebp]
  00049	e8 00 00 00 00	 call	 ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
  0004e	50		 push	 eax
  0004f	e8 00 00 00 00	 call	 ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ; ATL::CTraceFileAndLineInfo::operator()
  00054	83 c4 14	 add	 esp, 20			; 00000014H

; 67   : #ifdef _AFX
; 68   : 	if( hr == E_OUTOFMEMORY )

  00057	81 7d 08 0e 00
	07 80		 cmp	 DWORD PTR _hr$[ebp], -2147024882 ; 8007000eH
  0005e	75 07		 jne	 SHORT $LN2@AtlThrowIm

; 69   : 	{
; 70   : 		AfxThrowMemoryException();

  00060	e8 00 00 00 00	 call	 ?AfxThrowMemoryException@@YGXXZ ; AfxThrowMemoryException

; 71   : 	}
; 72   : 	else

  00065	eb 09		 jmp	 SHORT $LN4@AtlThrowIm
$LN2@AtlThrowIm:

; 73   : 	{
; 74   : 		AfxThrowOleException( hr );

  00067	8b 45 08	 mov	 eax, DWORD PTR _hr$[ebp]
  0006a	50		 push	 eax
  0006b	e8 00 00 00 00	 call	 ?AfxThrowOleException@@YGXJ@Z ; AfxThrowOleException
$LN4@AtlThrowIm:

; 75   : 	}
; 76   : #else
; 77   : 	throw CAtlException( hr );
; 78   : #endif
; 79   : };

  00070	5f		 pop	 edi
  00071	5e		 pop	 esi
  00072	5b		 pop	 ebx
  00073	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00079	3b ec		 cmp	 ebp, esp
  0007b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00080	8b e5		 mov	 esp, ebp
  00082	5d		 pop	 ebp
  00083	c2 04 00	 ret	 4
?AtlThrowImpl@ATL@@YGXJ@Z ENDP				; ATL::AtlThrowImpl
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlexcept.h
;	COMDAT ?_AtlRaiseException@ATL@@YAXKK@Z
_TEXT	SEGMENT
_dwExceptionCode$ = 8					; size = 4
_dwExceptionFlags$ = 12					; size = 4
?_AtlRaiseException@ATL@@YAXKK@Z PROC			; ATL::_AtlRaiseException, COMDAT

; 30   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 31   : 	RaiseException( dwExceptionCode, dwExceptionFlags, 0, NULL );

  0001e	8b f4		 mov	 esi, esp
  00020	6a 00		 push	 0
  00022	6a 00		 push	 0
  00024	8b 45 0c	 mov	 eax, DWORD PTR _dwExceptionFlags$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 08	 mov	 ecx, DWORD PTR _dwExceptionCode$[ebp]
  0002b	51		 push	 ecx
  0002c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__RaiseException@16
  00032	3b f4		 cmp	 esi, esp
  00034	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 32   : }

  00039	5f		 pop	 edi
  0003a	5e		 pop	 esi
  0003b	5b		 pop	 ebx
  0003c	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00042	3b ec		 cmp	 ebp, esp
  00044	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c3		 ret	 0
?_AtlRaiseException@ATL@@YAXKK@Z ENDP			; ATL::_AtlRaiseException
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ
_TEXT	SEGMENT
_ptr$ = -8						; size = 4
_this$ = 8						; size = 4
_dwCategory$ = 12					; size = 4
_nLevel$ = 16						; size = 4
_pszFmt$ = 20						; size = 4
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ PROC		; ATL::CTraceFileAndLineInfo::operator(), COMDAT

; 385  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 386  : 		va_list ptr; va_start(ptr, pszFmt);

  0001e	8d 45 18	 lea	 eax, DWORD PTR _pszFmt$[ebp+4]
  00021	89 45 f8	 mov	 DWORD PTR _ptr$[ebp], eax

; 387  : 		ATL::CTrace::TraceV(m_pszFileName, m_nLineNo, dwCategory, nLevel, pszFmt, ptr);

  00024	8b 45 f8	 mov	 eax, DWORD PTR _ptr$[ebp]
  00027	50		 push	 eax
  00028	8b 4d 14	 mov	 ecx, DWORD PTR _pszFmt$[ebp]
  0002b	51		 push	 ecx
  0002c	8b 55 10	 mov	 edx, DWORD PTR _nLevel$[ebp]
  0002f	52		 push	 edx
  00030	8b 45 0c	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  00033	50		 push	 eax
  00034	8b 4d 08	 mov	 ecx, DWORD PTR _this$[ebp]
  00037	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  0003a	52		 push	 edx
  0003b	8b 45 08	 mov	 eax, DWORD PTR _this$[ebp]
  0003e	8b 08		 mov	 ecx, DWORD PTR [eax]
  00040	51		 push	 ecx
  00041	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z ; ATL::CTrace::TraceV
  00046	83 c4 18	 add	 esp, 24			; 00000018H

; 388  : 		va_end(ptr);

  00049	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _ptr$[ebp], 0

; 389  : 	}

  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00059	3b ec		 cmp	 ebp, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	8b e5		 mov	 esp, ebp
  00062	5d		 pop	 ebp
  00063	c3		 ret	 0
??RCTraceFileAndLineInfo@ATL@@QBAXHIPB_WZZ ENDP		; ATL::CTraceFileAndLineInfo::operator()
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszFileName$ = 8					; size = 4
_nLineNo$ = 12						; size = 4
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z PROC		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo, COMDAT
; _this$ = ecx

; 361  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 4d 08	 mov	 ecx, DWORD PTR _pszFileName$[ebp]
  00029	89 08		 mov	 DWORD PTR [eax], ecx
  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	8b 4d 0c	 mov	 ecx, DWORD PTR _nLineNo$[ebp]
  00031	89 48 04	 mov	 DWORD PTR [eax+4], ecx

; 362  : 	}

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
??0CTraceFileAndLineInfo@ATL@@QAE@PBDH@Z ENDP		; ATL::CTraceFileAndLineInfo::CTraceFileAndLineInfo
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::__autoclassinit2, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 08	 mov	 eax, DWORD PTR _classSize$[ebp]
  00026	50		 push	 eax
  00027	6a 00		 push	 0
  00029	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0002c	51		 push	 ecx
  0002d	e8 00 00 00 00	 call	 _memset
  00032	83 c4 0c	 add	 esp, 12			; 0000000cH
  00035	5f		 pop	 edi
  00036	5e		 pop	 esi
  00037	5b		 pop	 ebx
  00038	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  0003e	3b ec		 cmp	 ebp, esp
  00040	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00045	8b e5		 mov	 esp, ebp
  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx
  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::~CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_nBytes$ = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
_nElements$ = 8						; size = 4
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate, COMDAT
; _this$ = ecx

; 470  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 24 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-220]
  00013	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00025	33 c5		 xor	 eax, ebp
  00027	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  0002a	89 4d f4	 mov	 DWORD PTR _this$[ebp], ecx

; 471  : 		size_t nBytes=0;

  0002d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _nBytes$[ebp], 0

; 472  : 		if(FAILED(::ATL::AtlMultiply(&nBytes, nElements, sizeof(T))))

  00034	6a 02		 push	 2
  00036	8b 45 08	 mov	 eax, DWORD PTR _nElements$[ebp]
  00039	50		 push	 eax
  0003a	8d 4d e8	 lea	 ecx, DWORD PTR _nBytes$[ebp]
  0003d	51		 push	 ecx
  0003e	e8 00 00 00 00	 call	 ??$AtlMultiply@I@ATL@@YAJPAIII@Z ; ATL::AtlMultiply<unsigned int>
  00043	83 c4 0c	 add	 esp, 12			; 0000000cH
  00046	85 c0		 test	 eax, eax
  00048	7d 04		 jge	 SHORT $LN1@Allocate

; 473  : 		{
; 474  : 			return false;

  0004a	32 c0		 xor	 al, al
  0004c	eb 0c		 jmp	 SHORT $LN2@Allocate
$LN1@Allocate:

; 475  : 		}
; 476  : 		return AllocateBytes(nBytes);

  0004e	8b 45 e8	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00051	50		 push	 eax
  00052	8b 4d f4	 mov	 ecx, DWORD PTR _this$[ebp]
  00055	e8 00 00 00 00	 call	 ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
$LN2@Allocate:

; 477  : 	}

  0005a	52		 push	 edx
  0005b	8b cd		 mov	 ecx, ebp
  0005d	50		 push	 eax
  0005e	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN6@Allocate
  00064	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00069	58		 pop	 eax
  0006a	5a		 pop	 edx
  0006b	5f		 pop	 edi
  0006c	5e		 pop	 esi
  0006d	5b		 pop	 ebx
  0006e	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00071	33 cd		 xor	 ecx, ebp
  00073	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00078	81 c4 dc 00 00
	00		 add	 esp, 220		; 000000dcH
  0007e	3b ec		 cmp	 ebp, esp
  00080	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00085	8b e5		 mov	 esp, ebp
  00087	5d		 pop	 ebp
  00088	c2 04 00	 ret	 4
  0008b	90		 npad	 1
$LN6@Allocate:
  0008c	01 00 00 00	 DD	 1
  00090	00 00 00 00	 DD	 $LN5@Allocate
$LN5@Allocate:
  00094	e8 ff ff ff	 DD	 -24			; ffffffe8H
  00098	04 00 00 00	 DD	 4
  0009c	00 00 00 00	 DD	 $LN4@Allocate
$LN4@Allocate:
  000a0	6e		 DB	 110			; 0000006eH
  000a1	42		 DB	 66			; 00000042H
  000a2	79		 DB	 121			; 00000079H
  000a3	74		 DB	 116			; 00000074H
  000a4	65		 DB	 101			; 00000065H
  000a5	73		 DB	 115			; 00000073H
  000a6	00		 DB	 0
?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 449  : 	CHeapPtr() throw()

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>

; 450  : 	{
; 451  : 	}

  0002b	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002e	5f		 pop	 edi
  0002f	5e		 pop	 esi
  00030	5b		 pop	 ebx
  00031	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00037	3b ec		 cmp	 ebp, esp
  00039	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP	; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free, COMDAT
; _this$ = ecx

; 422  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 423  : 		Allocator::Free(m_pData);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 08		 mov	 ecx, DWORD PTR [eax]
  00028	51		 push	 ecx
  00029	e8 00 00 00 00	 call	 ?Free@CCRTAllocator@ATL@@SAXPAX@Z ; ATL::CCRTAllocator::Free
  0002e	83 c4 04	 add	 esp, 4

; 424  : 		m_pData = NULL;

  00031	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00034	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 425  : 	}

  0003a	5f		 pop	 edi
  0003b	5e		 pop	 esi
  0003c	5b		 pop	 ebx
  0003d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00043	3b ec		 cmp	 ebp, esp
  00045	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0004a	8b e5		 mov	 esp, ebp
  0004c	5d		 pop	 ebp
  0004d	c3		 ret	 0
?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_nBytes$ = 8						; size = 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes, COMDAT
; _this$ = ecx

; 396  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 397  : 		ATLASSERT(m_pData == NULL);

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	83 38 00	 cmp	 DWORD PTR [eax], 0
  00029	74 30		 je	 SHORT $LN4@AllocateBy
  0002b	8b f4		 mov	 esi, esp
  0002d	68 00 00 00 00	 push	 OFFSET ??_C@_1BK@NHECDDNK@?$AAm?$AA_?$AAp?$AAD?$AAa?$AAt?$AAa?$AA?5?$AA?$DN?$AA?$DN?$AA?5?$AA0?$AA?$AA@
  00032	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00037	6a 00		 push	 0
  00039	68 8d 01 00 00	 push	 397			; 0000018dH
  0003e	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@BHGECGBJ@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  00043	6a 02		 push	 2
  00045	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0004b	83 c4 18	 add	 esp, 24			; 00000018H
  0004e	3b f4		 cmp	 esi, esp
  00050	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00055	83 f8 01	 cmp	 eax, 1
  00058	75 01		 jne	 SHORT $LN4@AllocateBy
  0005a	cc		 int	 3
$LN4@AllocateBy:

; 398  : 		m_pData = static_cast<T*>(Allocator::Allocate(nBytes));

  0005b	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  0005e	50		 push	 eax
  0005f	e8 00 00 00 00	 call	 ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ; ATL::CCRTAllocator::Allocate
  00064	83 c4 04	 add	 esp, 4
  00067	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  0006a	89 01		 mov	 DWORD PTR [ecx], eax

; 399  : 		if (m_pData == NULL)

  0006c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0006f	83 38 00	 cmp	 DWORD PTR [eax], 0
  00072	75 04		 jne	 SHORT $LN1@AllocateBy

; 400  : 			return false;

  00074	32 c0		 xor	 al, al
  00076	eb 02		 jmp	 SHORT $LN2@AllocateBy
$LN1@AllocateBy:

; 401  : 
; 402  : 		return true;

  00078	b0 01		 mov	 al, 1
$LN2@AllocateBy:

; 403  : 	}

  0007a	5f		 pop	 edi
  0007b	5e		 pop	 esi
  0007c	5b		 pop	 ebx
  0007d	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00083	3b ec		 cmp	 ebp, esp
  00085	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0008a	8b e5		 mov	 esp, ebp
  0008c	5d		 pop	 ebp
  0008d	c2 04 00	 ret	 4
?AllocateBytes@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::AllocateBytes
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *, COMDAT
; _this$ = ecx

; 378  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 379  : 		return m_pData;

  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	8b 00		 mov	 eax, DWORD PTR [eax]

; 380  : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 364  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 365  : 		Free();

  00023	8b 4d f8	 mov	 ecx, DWORD PTR _this$[ebp]
  00026	e8 00 00 00 00	 call	 ?Free@?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAEXXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::Free

; 366  : 	}

  0002b	5f		 pop	 edi
  0002c	5e		 pop	 esi
  0002d	5b		 pop	 ebx
  0002e	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00034	3b ec		 cmp	 ebp, esp
  00036	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003b	8b e5		 mov	 esp, ebp
  0003d	5d		 pop	 ebp
  0003e	c3		 ret	 0
??1?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::~CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ PROC ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>, COMDAT
; _this$ = ecx

; 351  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx
  00023	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00026	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 352  : 	}

  0002c	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  0002f	5f		 pop	 edi
  00030	5e		 pop	 esi
  00031	5b		 pop	 ebx
  00032	8b e5		 mov	 esp, ebp
  00034	5d		 pop	 ebp
  00035	c3		 ret	 0
??0?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@IAE@XZ ENDP ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z
_TEXT	SEGMENT
_pszCategory$ = 8					; size = 4
_nCategory$ = 12					; size = 4
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z PROC		; ATL::CTrace::RegisterCategory, COMDAT

; 300  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 301  : 		if (pszCategory == nullptr)

  0001e	83 7d 08 00	 cmp	 DWORD PTR _pszCategory$[ebp], 0
  00022	75 05		 jne	 SHORT $LN2@RegisterCa

; 302  : 		{
; 303  : 			return;

  00024	e9 88 00 00 00	 jmp	 $LN3@RegisterCa
$LN2@RegisterCa:

; 304  : 		}
; 305  : 
; 306  : 		if (m_nLastCategory >= MaxCategoryArray) 

  00029	83 3d 00 00 00
	00 20		 cmp	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 32 ; ATL::CTrace::m_nLastCategory, 00000020H
  00030	72 36		 jb	 SHORT $LN1@RegisterCa

; 307  : 		{
; 308  : 			ATLASSERT(false && "Too many categories defined");

  00032	33 c0		 xor	 eax, eax
  00034	75 30		 jne	 SHORT $LN5@RegisterCa
  00036	8b f4		 mov	 esi, esp
  00038	68 00 00 00 00	 push	 OFFSET ??_C@_1EO@EBPPKGOM@?$AAf?$AAa?$AAl?$AAs?$AAe?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA?$CC?$AAT?$AAo?$AAo?$AA?5?$AAm?$AAa?$AAn?$AAy?$AA?5?$AAc?$AAa?$AAt?$AAe?$AAg?$AAo?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAd?$AAe@
  0003d	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00042	6a 00		 push	 0
  00044	68 34 01 00 00	 push	 308			; 00000134H
  00049	68 00 00 00 00	 push	 OFFSET ??_C@_1KC@GEMPEEJK@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
  0004e	6a 02		 push	 2
  00050	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  00056	83 c4 18	 add	 esp, 24			; 00000018H
  00059	3b f4		 cmp	 esi, esp
  0005b	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00060	83 f8 01	 cmp	 eax, 1
  00063	75 01		 jne	 SHORT $LN5@RegisterCa
  00065	cc		 int	 3
$LN5@RegisterCa:

; 309  : 			return;

  00066	eb 49		 jmp	 SHORT $LN3@RegisterCa
$LN1@RegisterCa:

; 310  : 		}
; 311  : 
; 312  : 		m_nMap[m_nLastCategory].nCategory = nCategory;

  00068	69 05 00 00 00
	00 04 01 00 00	 imul	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  00072	8b 4d 0c	 mov	 ecx, DWORD PTR _nCategory$[ebp]
  00075	89 88 00 00 00
	00		 mov	 DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax], ecx

; 313  : #ifdef _UNICODE
; 314  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, pszCategory);

  0007b	8b f4		 mov	 esi, esp
  0007d	8b 45 08	 mov	 eax, DWORD PTR _pszCategory$[ebp]
  00080	50		 push	 eax
  00081	6a 7f		 push	 127			; 0000007fH
  00083	69 0d 00 00 00
	00 04 01 00 00	 imul	 ecx, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, 260 ; ATL::CTrace::m_nLastCategory
  0008d	81 c1 04 00 00
	00		 add	 ecx, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  00093	51		 push	 ecx
  00094	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcscpy_s
  0009a	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009d	3b f4		 cmp	 esi, esp
  0009f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 315  : #else
; 316  : 		wchar_t buffer[MaxLengthOfCategoryName] = { 0 };	
; 317  : 		swprintf_s(buffer, MaxLengthOfCategoryName - 1, L"%S", pszCategory);
; 318  : 		wcscpy_s(m_nMap[m_nLastCategory].categryName, MaxLengthOfCategoryName - 1, buffer);
; 319  : #endif
; 320  : 	
; 321  : 		m_nLastCategory++;

  000a4	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  000a9	83 c0 01	 add	 eax, 1
  000ac	a3 00 00 00 00	 mov	 DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA, eax ; ATL::CTrace::m_nLastCategory
$LN3@RegisterCa:

; 322  : 	}

  000b1	5f		 pop	 edi
  000b2	5e		 pop	 esi
  000b3	5b		 pop	 ebx
  000b4	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  000ba	3b ec		 cmp	 ebp, esp
  000bc	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000c1	8b e5		 mov	 esp, ebp
  000c3	5d		 pop	 ebp
  000c4	c3		 ret	 0
?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ENDP		; ATL::CTrace::RegisterCategory
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
_TEXT	SEGMENT
_wszBuf$ = -36						; size = 4
_cchNeeded$ = -24					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszFmt$ = 24						; size = 4
_args$ = 28						; size = 4
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	6a ff		 push	 -1
  00005	68 00 00 00 00	 push	 __ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
  0000a	64 a1 00 00 00
	00		 mov	 eax, DWORD PTR fs:0
  00010	50		 push	 eax
  00011	81 ec dc 00 00
	00		 sub	 esp, 220		; 000000dcH
  00017	53		 push	 ebx
  00018	56		 push	 esi
  00019	57		 push	 edi
  0001a	8d bd 18 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-232]
  00020	b9 37 00 00 00	 mov	 ecx, 55			; 00000037H
  00025	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0002a	f3 ab		 rep stosd
  0002c	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00031	33 c5		 xor	 eax, ebp
  00033	89 45 f0	 mov	 DWORD PTR __$ArrayPad$[ebp], eax
  00036	50		 push	 eax
  00037	8d 45 f4	 lea	 eax, DWORD PTR __$EHRec$[ebp]
  0003a	64 a3 00 00 00
	00		 mov	 DWORD PTR fs:0, eax

; 277  : 		int cchNeeded = _vscwprintf(pwszFmt, args);

  00040	8b f4		 mov	 esi, esp
  00042	8b 45 1c	 mov	 eax, DWORD PTR _args$[ebp]
  00045	50		 push	 eax
  00046	8b 4d 18	 mov	 ecx, DWORD PTR _pwszFmt$[ebp]
  00049	51		 push	 ecx
  0004a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vscwprintf
  00050	83 c4 08	 add	 esp, 8
  00053	3b f4		 cmp	 esi, esp
  00055	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005a	89 45 e8	 mov	 DWORD PTR _cchNeeded$[ebp], eax

; 278  : 		if (cchNeeded < 0)

  0005d	83 7d e8 00	 cmp	 DWORD PTR _cchNeeded$[ebp], 0
  00061	7d 05		 jge	 SHORT $LN3@TraceV

; 279  : 		{
; 280  : 			return;

  00063	e9 cd 00 00 00	 jmp	 $LN4@TraceV
$LN3@TraceV:

; 281  : 		}
; 282  : 
; 283  : 		CHeapPtr<wchar_t> wszBuf;

  00068	6a 04		 push	 4
  0006a	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0006d	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z
  00072	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00075	e8 00 00 00 00	 call	 ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>
  0007a	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR __$EHRec$[ebp+8], 0

; 284  : 		if (!wszBuf.Allocate(cchNeeded + 1))

  00081	8b 45 e8	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  00084	83 c0 01	 add	 eax, 1
  00087	50		 push	 eax
  00088	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0008b	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  00090	0f b6 c8	 movzx	 ecx, al
  00093	85 c9		 test	 ecx, ecx
  00095	75 14		 jne	 SHORT $LN2@TraceV

; 285  : 		{
; 286  : 			return;

  00097	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0009e	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000a1	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  000a6	e9 8a 00 00 00	 jmp	 $LN4@TraceV
$LN2@TraceV:

; 287  : 		}
; 288  : 
; 289  : 		wszBuf[0] = '\0';

  000ab	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000ae	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  000b3	b9 02 00 00 00	 mov	 ecx, 2
  000b8	6b d1 00	 imul	 edx, ecx, 0
  000bb	33 c9		 xor	 ecx, ecx
  000bd	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 290  : 
; 291  : 		if (_vsnwprintf_s(wszBuf, cchNeeded + 1, cchNeeded, pwszFmt, args) == -1)

  000c1	8b f4		 mov	 esi, esp
  000c3	8b 45 1c	 mov	 eax, DWORD PTR _args$[ebp]
  000c6	50		 push	 eax
  000c7	8b 4d 18	 mov	 ecx, DWORD PTR _pwszFmt$[ebp]
  000ca	51		 push	 ecx
  000cb	8b 55 e8	 mov	 edx, DWORD PTR _cchNeeded$[ebp]
  000ce	52		 push	 edx
  000cf	8b 45 e8	 mov	 eax, DWORD PTR _cchNeeded$[ebp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	50		 push	 eax
  000d6	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000d9	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  000de	50		 push	 eax
  000df	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnwprintf_s
  000e5	83 c4 14	 add	 esp, 20			; 00000014H
  000e8	3b f4		 cmp	 esi, esp
  000ea	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000ef	83 f8 ff	 cmp	 eax, -1
  000f2	75 11		 jne	 SHORT $LN1@TraceV

; 292  : 		{
; 293  : 			return;

  000f4	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  000fb	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  000fe	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  00103	eb 30		 jmp	 SHORT $LN4@TraceV
$LN1@TraceV:

; 294  : 		}
; 295  : 
; 296  : 		TraceV(pszFileName, nLine, dwCategory, nLevel, wszBuf);

  00105	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00108	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  0010d	50		 push	 eax
  0010e	8b 45 14	 mov	 eax, DWORD PTR _nLevel$[ebp]
  00111	50		 push	 eax
  00112	8b 4d 10	 mov	 ecx, DWORD PTR _dwCategory$[ebp]
  00115	51		 push	 ecx
  00116	8b 55 0c	 mov	 edx, DWORD PTR _nLine$[ebp]
  00119	52		 push	 edx
  0011a	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  0011d	50		 push	 eax
  0011e	e8 00 00 00 00	 call	 ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ; ATL::CTrace::TraceV
  00123	83 c4 14	 add	 esp, 20			; 00000014H

; 297  : 	}

  00126	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR __$EHRec$[ebp+8], -1
  0012d	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00130	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN4@TraceV:
  00135	52		 push	 edx
  00136	8b cd		 mov	 ecx, ebp
  00138	50		 push	 eax
  00139	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN10@TraceV
  0013f	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00144	58		 pop	 eax
  00145	5a		 pop	 edx
  00146	8b 4d f4	 mov	 ecx, DWORD PTR __$EHRec$[ebp]
  00149	64 89 0d 00 00
	00 00		 mov	 DWORD PTR fs:0, ecx
  00150	59		 pop	 ecx
  00151	5f		 pop	 edi
  00152	5e		 pop	 esi
  00153	5b		 pop	 ebx
  00154	8b 4d f0	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  00157	33 cd		 xor	 ecx, ebp
  00159	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0015e	81 c4 e8 00 00
	00		 add	 esp, 232		; 000000e8H
  00164	3b ec		 cmp	 ebp, esp
  00166	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0016b	8b e5		 mov	 esp, ebp
  0016d	5d		 pop	 ebp
  0016e	c3		 ret	 0
  0016f	90		 npad	 1
$LN10@TraceV:
  00170	01 00 00 00	 DD	 1
  00174	00 00 00 00	 DD	 $LN9@TraceV
$LN9@TraceV:
  00178	dc ff ff ff	 DD	 -36			; ffffffdcH
  0017c	04 00 00 00	 DD	 4
  00180	00 00 00 00	 DD	 $LN7@TraceV
$LN7@TraceV:
  00184	77		 DB	 119			; 00000077H
  00185	73		 DB	 115			; 00000073H
  00186	7a		 DB	 122			; 0000007aH
  00187	42		 DB	 66			; 00000042H
  00188	75		 DB	 117			; 00000075H
  00189	66		 DB	 102			; 00000066H
  0018a	00		 DB	 0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z$0:
  00000	8d 4d dc	 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00003	e9 00 00 00 00	 jmp	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
__ehhandler$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z:
  00008	8b 54 24 08	 mov	 edx, DWORD PTR [esp+8]
  0000c	8d 42 0c	 lea	 eax, DWORD PTR [edx+12]
  0000f	8b 8a 14 ff ff
	ff		 mov	 ecx, DWORD PTR [edx-236]
  00015	33 c8		 xor	 ecx, eax
  00017	e8 00 00 00 00	 call	 @__security_check_cookie@4
  0001c	8b 4a fc	 mov	 ecx, DWORD PTR [edx-4]
  0001f	33 c8		 xor	 ecx, eax
  00021	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00026	b8 00 00 00 00	 mov	 eax, OFFSET __ehfuncinfo$?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z
  0002b	e9 00 00 00 00	 jmp	 ___CxxFrameHandler3
text$x	ENDS
?TraceV@CTrace@ATL@@SAXPBDHIIPB_WPAD@Z ENDP		; ATL::CTrace::TraceV
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z
_TEXT	SEGMENT
_fileName$ = -2632					; size = 520
_wszBuf$ = -2104					; size = 4
_chCount$ = -2092					; size = 4
_pwszCategoryName$ = -2080				; size = 4
_categoryLength$ = -2068				; size = 4
_wszCategory$ = -2056					; size = 2048
__$ArrayPad$ = -4					; size = 4
_pszFileName$ = 8					; size = 4
_nLine$ = 12						; size = 4
_dwCategory$ = 16					; size = 4
_nLevel$ = 20						; size = 4
_pwszMessage$ = 24					; size = 4
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z PROC		; ATL::CTrace::TraceV, COMDAT

; 149  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 0c 0b 00
	00		 sub	 esp, 2828		; 00000b0cH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd f4 f4 ff
	ff		 lea	 edi, DWORD PTR [ebp-2828]
  00012	b9 c3 02 00 00	 mov	 ecx, 707		; 000002c3H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	a1 00 00 00 00	 mov	 eax, DWORD PTR ___security_cookie
  00023	33 c5		 xor	 eax, ebp
  00025	89 45 fc	 mov	 DWORD PTR __$ArrayPad$[ebp], eax

; 150  : 		if (CTrace::m_nLevel == CTrace::DisableTracing || CTrace::m_nLevel < nLevel || (CTrace::m_nCategory & dwCategory) == 0)

  00028	83 3d 00 00 00
	00 ff		 cmp	 DWORD PTR ?m_nLevel@CTrace@ATL@@1IA, -1 ; ATL::CTrace::m_nLevel
  0002f	74 14		 je	 SHORT $LN8@TraceV
  00031	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nLevel@CTrace@ATL@@1IA ; ATL::CTrace::m_nLevel
  00036	3b 45 14	 cmp	 eax, DWORD PTR _nLevel$[ebp]
  00039	72 0a		 jb	 SHORT $LN8@TraceV
  0003b	a1 00 00 00 00	 mov	 eax, DWORD PTR ?m_nCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nCategory
  00040	23 45 10	 and	 eax, DWORD PTR _dwCategory$[ebp]
  00043	75 05		 jne	 SHORT $LN9@TraceV
$LN8@TraceV:

; 151  : 		{
; 152  : 			return;

  00045	e9 19 02 00 00	 jmp	 $LN10@TraceV
$LN9@TraceV:

; 153  : 		}
; 154  : 
; 155  : 		wchar_t wszCategory[TraceBufferSize] = {'\0'};

  0004a	33 c0		 xor	 eax, eax
  0004c	66 89 85 f8 f7
	ff ff		 mov	 WORD PTR _wszCategory$[ebp], ax
  00053	68 fe 07 00 00	 push	 2046			; 000007feH
  00058	6a 00		 push	 0
  0005a	8d 85 fa f7 ff
	ff		 lea	 eax, DWORD PTR _wszCategory$[ebp+2]
  00060	50		 push	 eax
  00061	e8 00 00 00 00	 call	 _memset
  00066	83 c4 0c	 add	 esp, 12			; 0000000cH

; 156  : 		int categoryLength = 0;

  00069	c7 85 ec f7 ff
	ff 00 00 00 00	 mov	 DWORD PTR _categoryLength$[ebp], 0

; 157  : 		const wchar_t *const pwszCategoryName = GetCategoryName(dwCategory);

  00073	8b 45 10	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  00076	50		 push	 eax
  00077	e8 00 00 00 00	 call	 ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ; ATL::CTrace::GetCategoryName
  0007c	83 c4 04	 add	 esp, 4
  0007f	89 85 e0 f7 ff
	ff		 mov	 DWORD PTR _pwszCategoryName$[ebp], eax

; 158  : 		if (pwszCategoryName != nullptr)

  00085	83 bd e0 f7 ff
	ff 00		 cmp	 DWORD PTR _pwszCategoryName$[ebp], 0
  0008c	74 40		 je	 SHORT $LN7@TraceV

; 159  : 		{
; 160  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%s - ", pwszCategoryName)) == -1)

  0008e	8b f4		 mov	 esi, esp
  00090	8b 85 e0 f7 ff
	ff		 mov	 eax, DWORD PTR _pwszCategoryName$[ebp]
  00096	50		 push	 eax
  00097	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PLLAHAGD@?$AA?$CF?$AAs?$AA?5?$AA?9?$AA?5?$AA?$AA@
  0009c	68 00 04 00 00	 push	 1024			; 00000400H
  000a1	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  000a7	51		 push	 ecx
  000a8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  000ae	83 c4 10	 add	 esp, 16			; 00000010H
  000b1	3b f4		 cmp	 esi, esp
  000b3	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000b8	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _categoryLength$[ebp], eax
  000be	83 bd ec f7 ff
	ff ff		 cmp	 DWORD PTR _categoryLength$[ebp], -1
  000c5	75 05		 jne	 SHORT $LN6@TraceV

; 161  : 			{
; 162  : 				return;

  000c7	e9 97 01 00 00	 jmp	 $LN10@TraceV
$LN6@TraceV:

; 163  : 			}
; 164  : 		}
; 165  : 		else

  000cc	eb 3b		 jmp	 SHORT $LN5@TraceV
$LN7@TraceV:

; 166  : 		{
; 167  : 			if ((categoryLength = swprintf_s(wszCategory, TraceBufferSize, L"%u - ", dwCategory)) == -1)

  000ce	8b f4		 mov	 esi, esp
  000d0	8b 45 10	 mov	 eax, DWORD PTR _dwCategory$[ebp]
  000d3	50		 push	 eax
  000d4	68 00 00 00 00	 push	 OFFSET ??_C@_1M@PGKOAACE@?$AA?$CF?$AAu?$AA?5?$AA?9?$AA?5?$AA?$AA@
  000d9	68 00 04 00 00	 push	 1024			; 00000400H
  000de	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  000e4	51		 push	 ecx
  000e5	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  000eb	83 c4 10	 add	 esp, 16			; 00000010H
  000ee	3b f4		 cmp	 esi, esp
  000f0	e8 00 00 00 00	 call	 __RTC_CheckEsp
  000f5	89 85 ec f7 ff
	ff		 mov	 DWORD PTR _categoryLength$[ebp], eax
  000fb	83 bd ec f7 ff
	ff ff		 cmp	 DWORD PTR _categoryLength$[ebp], -1
  00102	75 05		 jne	 SHORT $LN5@TraceV

; 168  : 			{
; 169  : 				return;

  00104	e9 5a 01 00 00	 jmp	 $LN10@TraceV
$LN5@TraceV:

; 170  : 			}
; 171  : 		}
; 172  : 
; 173  : 		int chCount = (int)wcslen(pwszMessage) + categoryLength + 1;

  00109	8b f4		 mov	 esi, esp
  0010b	8b 45 18	 mov	 eax, DWORD PTR _pwszMessage$[ebp]
  0010e	50		 push	 eax
  0010f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__wcslen
  00115	83 c4 04	 add	 esp, 4
  00118	3b f4		 cmp	 esi, esp
  0011a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0011f	8b 8d ec f7 ff
	ff		 mov	 ecx, DWORD PTR _categoryLength$[ebp]
  00125	8d 54 08 01	 lea	 edx, DWORD PTR [eax+ecx+1]
  00129	89 95 d4 f7 ff
	ff		 mov	 DWORD PTR _chCount$[ebp], edx

; 174  : 		CHeapPtr<wchar_t> wszBuf;

  0012f	6a 04		 push	 4
  00131	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00137	e8 00 00 00 00	 call	 ?__autoclassinit2@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAEXI@Z
  0013c	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00142	e8 00 00 00 00	 call	 ??0?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::CHeapPtr<wchar_t,ATL::CCRTAllocator>

; 175  : 		if (!wszBuf.Allocate(chCount))

  00147	8b 85 d4 f7 ff
	ff		 mov	 eax, DWORD PTR _chCount$[ebp]
  0014d	50		 push	 eax
  0014e	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00154	e8 00 00 00 00	 call	 ?Allocate@?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE_NI@Z ; ATL::CHeapPtr<wchar_t,ATL::CCRTAllocator>::Allocate
  00159	0f b6 c8	 movzx	 ecx, al
  0015c	85 c9		 test	 ecx, ecx
  0015e	75 10		 jne	 SHORT $LN3@TraceV

; 176  : 		{
; 177  : 			return;

  00160	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00166	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  0016b	e9 f3 00 00 00	 jmp	 $LN10@TraceV
$LN3@TraceV:

; 178  : 		}
; 179  : 
; 180  : 		wszBuf[0] = '\0';

  00170	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00176	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  0017b	b9 02 00 00 00	 mov	 ecx, 2
  00180	6b d1 00	 imul	 edx, ecx, 0
  00183	33 c9		 xor	 ecx, ecx
  00185	66 89 0c 10	 mov	 WORD PTR [eax+edx], cx

; 181  : 
; 182  : 		if (swprintf_s(wszBuf, chCount, L"%s%s", wszCategory, pwszMessage) == -1)

  00189	8b f4		 mov	 esi, esp
  0018b	8b 45 18	 mov	 eax, DWORD PTR _pwszMessage$[ebp]
  0018e	50		 push	 eax
  0018f	8d 8d f8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszCategory$[ebp]
  00195	51		 push	 ecx
  00196	68 00 00 00 00	 push	 OFFSET ??_C@_19LJDFFCJJ@?$AA?$CF?$AAs?$AA?$CF?$AAs?$AA?$AA@
  0019b	8b 95 d4 f7 ff
	ff		 mov	 edx, DWORD PTR _chCount$[ebp]
  001a1	52		 push	 edx
  001a2	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  001a8	e8 00 00 00 00	 call	 ??B?$CHeapPtrBase@_WVCCRTAllocator@ATL@@@ATL@@QBEPA_WXZ ; ATL::CHeapPtrBase<wchar_t,ATL::CCRTAllocator>::operator wchar_t *
  001ad	50		 push	 eax
  001ae	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  001b4	83 c4 14	 add	 esp, 20			; 00000014H
  001b7	3b f4		 cmp	 esi, esp
  001b9	e8 00 00 00 00	 call	 __RTC_CheckEsp
  001be	83 f8 ff	 cmp	 eax, -1
  001c1	75 10		 jne	 SHORT $LN2@TraceV

; 183  : 		{
; 184  : 			return;

  001c3	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  001c9	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  001ce	e9 90 00 00 00	 jmp	 $LN10@TraceV
$LN2@TraceV:

; 185  : 		}
; 186  : 
; 187  : 		wchar_t fileName[_MAX_PATH] = {'\0'};	

  001d3	33 c0		 xor	 eax, eax
  001d5	66 89 85 b8 f5
	ff ff		 mov	 WORD PTR _fileName$[ebp], ax
  001dc	68 06 02 00 00	 push	 518			; 00000206H
  001e1	6a 00		 push	 0
  001e3	8d 85 ba f5 ff
	ff		 lea	 eax, DWORD PTR _fileName$[ebp+2]
  001e9	50		 push	 eax
  001ea	e8 00 00 00 00	 call	 _memset
  001ef	83 c4 0c	 add	 esp, 12			; 0000000cH

; 188  : 		if (swprintf_s(fileName, _MAX_PATH, L"%S", pszFileName) == -1)

  001f2	8b f4		 mov	 esi, esp
  001f4	8b 45 08	 mov	 eax, DWORD PTR _pszFileName$[ebp]
  001f7	50		 push	 eax
  001f8	68 00 00 00 00	 push	 OFFSET ??_C@_15MAOEGKJF@?$AA?$CF?$AAS?$AA?$AA@
  001fd	68 04 01 00 00	 push	 260			; 00000104H
  00202	8d 8d b8 f5 ff
	ff		 lea	 ecx, DWORD PTR _fileName$[ebp]
  00208	51		 push	 ecx
  00209	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__swprintf_s
  0020f	83 c4 10	 add	 esp, 16			; 00000010H
  00212	3b f4		 cmp	 esi, esp
  00214	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00219	83 f8 ff	 cmp	 eax, -1
  0021c	75 0d		 jne	 SHORT $LN1@TraceV

; 189  : 		{
; 190  : 			return;

  0021e	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  00224	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
  00229	eb 38		 jmp	 SHORT $LN10@TraceV
$LN1@TraceV:

; 191  : 		}
; 192  : 
; 193  : 		_CrtDbgReportW(_CRT_WARN, fileName, nLine, nullptr, L"%s", wszBuf);

  0022b	8b f4		 mov	 esi, esp
  0022d	8b 85 c8 f7 ff
	ff		 mov	 eax, DWORD PTR _wszBuf$[ebp]
  00233	50		 push	 eax
  00234	68 00 00 00 00	 push	 OFFSET ??_C@_15GANGMFKL@?$AA?$CF?$AAs?$AA?$AA@
  00239	6a 00		 push	 0
  0023b	8b 4d 0c	 mov	 ecx, DWORD PTR _nLine$[ebp]
  0023e	51		 push	 ecx
  0023f	8d 95 b8 f5 ff
	ff		 lea	 edx, DWORD PTR _fileName$[ebp]
  00245	52		 push	 edx
  00246	6a 00		 push	 0
  00248	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___CrtDbgReportW
  0024e	83 c4 18	 add	 esp, 24			; 00000018H
  00251	3b f4		 cmp	 esi, esp
  00253	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 194  : 	}

  00258	8d 8d c8 f7 ff
	ff		 lea	 ecx, DWORD PTR _wszBuf$[ebp]
  0025e	e8 00 00 00 00	 call	 ??1?$CHeapPtr@_WVCCRTAllocator@ATL@@@ATL@@QAE@XZ
$LN10@TraceV:
  00263	52		 push	 edx
  00264	8b cd		 mov	 ecx, ebp
  00266	50		 push	 eax
  00267	8d 15 00 00 00
	00		 lea	 edx, DWORD PTR $LN17@TraceV
  0026d	e8 00 00 00 00	 call	 @_RTC_CheckStackVars@8
  00272	58		 pop	 eax
  00273	5a		 pop	 edx
  00274	5f		 pop	 edi
  00275	5e		 pop	 esi
  00276	5b		 pop	 ebx
  00277	8b 4d fc	 mov	 ecx, DWORD PTR __$ArrayPad$[ebp]
  0027a	33 cd		 xor	 ecx, ebp
  0027c	e8 00 00 00 00	 call	 @__security_check_cookie@4
  00281	81 c4 0c 0b 00
	00		 add	 esp, 2828		; 00000b0cH
  00287	3b ec		 cmp	 ebp, esp
  00289	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0028e	8b e5		 mov	 esp, ebp
  00290	5d		 pop	 ebp
  00291	c3		 ret	 0
  00292	8b ff		 npad	 2
$LN17@TraceV:
  00294	03 00 00 00	 DD	 3
  00298	00 00 00 00	 DD	 $LN16@TraceV
$LN16@TraceV:
  0029c	f8 f7 ff ff	 DD	 -2056			; fffff7f8H
  002a0	00 08 00 00	 DD	 2048			; 00000800H
  002a4	00 00 00 00	 DD	 $LN13@TraceV
  002a8	c8 f7 ff ff	 DD	 -2104			; fffff7c8H
  002ac	04 00 00 00	 DD	 4
  002b0	00 00 00 00	 DD	 $LN14@TraceV
  002b4	b8 f5 ff ff	 DD	 -2632			; fffff5b8H
  002b8	08 02 00 00	 DD	 520			; 00000208H
  002bc	00 00 00 00	 DD	 $LN15@TraceV
$LN15@TraceV:
  002c0	66		 DB	 102			; 00000066H
  002c1	69		 DB	 105			; 00000069H
  002c2	6c		 DB	 108			; 0000006cH
  002c3	65		 DB	 101			; 00000065H
  002c4	4e		 DB	 78			; 0000004eH
  002c5	61		 DB	 97			; 00000061H
  002c6	6d		 DB	 109			; 0000006dH
  002c7	65		 DB	 101			; 00000065H
  002c8	00		 DB	 0
$LN14@TraceV:
  002c9	77		 DB	 119			; 00000077H
  002ca	73		 DB	 115			; 00000073H
  002cb	7a		 DB	 122			; 0000007aH
  002cc	42		 DB	 66			; 00000042H
  002cd	75		 DB	 117			; 00000075H
  002ce	66		 DB	 102			; 00000066H
  002cf	00		 DB	 0
$LN13@TraceV:
  002d0	77		 DB	 119			; 00000077H
  002d1	73		 DB	 115			; 00000073H
  002d2	7a		 DB	 122			; 0000007aH
  002d3	43		 DB	 67			; 00000043H
  002d4	61		 DB	 97			; 00000061H
  002d5	74		 DB	 116			; 00000074H
  002d6	65		 DB	 101			; 00000065H
  002d7	67		 DB	 103			; 00000067H
  002d8	6f		 DB	 111			; 0000006fH
  002d9	72		 DB	 114			; 00000072H
  002da	79		 DB	 121			; 00000079H
  002db	00		 DB	 0
?TraceV@CTrace@ATL@@CAXPBDHIIPB_W@Z ENDP		; ATL::CTrace::TraceV
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ?GetCategoryName@CTrace@ATL@@CAPA_WI@Z
_TEXT	SEGMENT
_i$1 = -8						; size = 4
_nCategory$ = 8						; size = 4
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z PROC		; ATL::CTrace::GetCategoryName, COMDAT

; 131  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00012	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 132  : 		for(unsigned int i = 0; i < m_nLastCategory; i++) 

  0001e	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _i$1[ebp], 0
  00025	eb 09		 jmp	 SHORT $LN4@GetCategor
$LN3@GetCategor:
  00027	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  0002a	83 c0 01	 add	 eax, 1
  0002d	89 45 f8	 mov	 DWORD PTR _i$1[ebp], eax
$LN4@GetCategor:
  00030	8b 45 f8	 mov	 eax, DWORD PTR _i$1[ebp]
  00033	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR ?m_nLastCategory@CTrace@ATL@@1IA ; ATL::CTrace::m_nLastCategory
  00039	73 22		 jae	 SHORT $LN2@GetCategor

; 133  : 		{
; 134  : 			if (m_nMap[i].nCategory == nCategory)

  0003b	69 45 f8 04 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 260
  00042	8b 88 00 00 00
	00		 mov	 ecx, DWORD PTR ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A[eax]
  00048	3b 4d 08	 cmp	 ecx, DWORD PTR _nCategory$[ebp]
  0004b	75 0e		 jne	 SHORT $LN1@GetCategor

; 135  : 			{
; 136  : 				return m_nMap[i].categryName;

  0004d	69 45 f8 04 01
	00 00		 imul	 eax, DWORD PTR _i$1[ebp], 260
  00054	05 04 00 00 00	 add	 eax, OFFSET ?m_nMap@CTrace@ATL@@1PAUCategoryMap@12@A+4
  00059	eb 04		 jmp	 SHORT $LN5@GetCategor
$LN1@GetCategor:

; 137  : 			}
; 138  : 		}

  0005b	eb ca		 jmp	 SHORT $LN3@GetCategor
$LN2@GetCategor:

; 139  : 
; 140  : 		return nullptr;

  0005d	33 c0		 xor	 eax, eax
$LN5@GetCategor:

; 141  : 	}

  0005f	5f		 pop	 edi
  00060	5e		 pop	 esi
  00061	5b		 pop	 ebx
  00062	8b e5		 mov	 esp, ebp
  00064	5d		 pop	 ebp
  00065	c3		 ret	 0
?GetCategoryName@CTrace@ATL@@CAPA_WI@Z ENDP		; ATL::CTrace::GetCategoryName
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??__EatlTraceException@ATL@@YAXXZ
text$di	SEGMENT
??__EatlTraceException@ATL@@YAXXZ PROC			; ATL::`dynamic initializer for 'atlTraceException'', COMDAT

; 109  : __declspec(selectany) CTraceCategoryEx<CTraceCategoryEx<>::TraceException> atlTraceException(_T("atlTraceException"));

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	68 00 00 00 00	 push	 OFFSET ??_C@_1CE@IMMADNAP@?$AAa?$AAt?$AAl?$AAT?$AAr?$AAa?$AAc?$AAe?$AAE?$AAx?$AAc?$AAe?$AAp?$AAt?$AAi?$AAo?$AAn?$AA?$AA@
  00023	b9 00 00 00 00	 mov	 ecx, OFFSET ?atlTraceException@ATL@@3V?$CTraceCategoryEx@$0CAAA@$0A@@1@A ; ATL::atlTraceException
  00028	e8 00 00 00 00	 call	 ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
  0002d	5f		 pop	 edi
  0002e	5e		 pop	 esi
  0002f	5b		 pop	 ebx
  00030	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  00036	3b ec		 cmp	 ebp, esp
  00038	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0003d	8b e5		 mov	 esp, ebp
  0003f	5d		 pop	 ebp
  00040	c3		 ret	 0
??__EatlTraceException@ATL@@YAXXZ ENDP			; ATL::`dynamic initializer for 'atlTraceException''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ PROC	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int, COMDAT
; _this$ = ecx

; 78   : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 79   : #ifdef _DEBUG
; 80   : 		return traceCategory;

  00023	b8 00 20 00 00	 mov	 eax, 8192		; 00002000H

; 81   : #else
; 82   : 		return 0;
; 83   : #endif
; 84   : 	}

  00028	5f		 pop	 edi
  00029	5e		 pop	 esi
  0002a	5b		 pop	 ebx
  0002b	8b e5		 mov	 esp, ebp
  0002d	5d		 pop	 ebp
  0002e	c3		 ret	 0
??B?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAEIXZ ENDP	; ATL::CTraceCategoryEx<8192,0>::operator unsigned int
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atltrace.h
;	COMDAT ??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_pszCategoryName$ = 8					; size = 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z PROC	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>, COMDAT
; _this$ = ecx

; 426  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec cc 00 00
	00		 sub	 esp, 204		; 000000ccH
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	51		 push	 ecx
  0000d	8d bd 34 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-204]
  00013	b9 33 00 00 00	 mov	 ecx, 51			; 00000033H
  00018	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001d	f3 ab		 rep stosd
  0001f	59		 pop	 ecx
  00020	89 4d f8	 mov	 DWORD PTR _this$[ebp], ecx

; 427  : 	CTrace::RegisterCategory(pszCategoryName, traceCategory);

  00023	68 00 20 00 00	 push	 8192			; 00002000H
  00028	8b 45 08	 mov	 eax, DWORD PTR _pszCategoryName$[ebp]
  0002b	50		 push	 eax
  0002c	e8 00 00 00 00	 call	 ?RegisterCategory@CTrace@ATL@@SAXPB_WI@Z ; ATL::CTrace::RegisterCategory
  00031	83 c4 08	 add	 esp, 8

; 428  : }

  00034	8b 45 f8	 mov	 eax, DWORD PTR _this$[ebp]
  00037	5f		 pop	 edi
  00038	5e		 pop	 esi
  00039	5b		 pop	 ebx
  0003a	81 c4 cc 00 00
	00		 add	 esp, 204		; 000000ccH
  00040	3b ec		 cmp	 ebp, esp
  00042	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00047	8b e5		 mov	 esp, ebp
  00049	5d		 pop	 ebp
  0004a	c2 04 00	 ret	 4
??0?$CTraceCategoryEx@$0CAAA@$0A@@ATL@@QAE@PB_W@Z ENDP	; ATL::CTraceCategoryEx<8192,0>::CTraceCategoryEx<8192,0>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Free@CCRTAllocator@ATL@@SAXPAX@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?Free@CCRTAllocator@ATL@@SAXPAX@Z PROC			; ATL::CCRTAllocator::Free, COMDAT

; 281  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 282  : 		free(p);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _p$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 283  : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Free@CCRTAllocator@ATL@@SAXPAX@Z ENDP			; ATL::CCRTAllocator::Free
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ?Allocate@CCRTAllocator@ATL@@SAPAXI@Z
_TEXT	SEGMENT
_nBytes$ = 8						; size = 4
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z PROC		; ATL::CCRTAllocator::Allocate, COMDAT

; 276  : 	{

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c0 00 00
	00		 sub	 esp, 192		; 000000c0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 40 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-192]
  00012	b9 30 00 00 00	 mov	 ecx, 48			; 00000030H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 277  : 		return malloc(nBytes);

  0001e	8b f4		 mov	 esi, esp
  00020	8b 45 08	 mov	 eax, DWORD PTR _nBytes$[ebp]
  00023	50		 push	 eax
  00024	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0002a	83 c4 04	 add	 esp, 4
  0002d	3b f4		 cmp	 esi, esp
  0002f	e8 00 00 00 00	 call	 __RTC_CheckEsp

; 278  : 	}

  00034	5f		 pop	 edi
  00035	5e		 pop	 esi
  00036	5b		 pop	 ebx
  00037	81 c4 c0 00 00
	00		 add	 esp, 192		; 000000c0H
  0003d	3b ec		 cmp	 ebp, esp
  0003f	e8 00 00 00 00	 call	 __RTC_CheckEsp
  00044	8b e5		 mov	 esp, ebp
  00046	5d		 pop	 ebp
  00047	c3		 ret	 0
?Allocate@CCRTAllocator@ATL@@SAPAXI@Z ENDP		; ATL::CCRTAllocator::Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 12.0\vc\atlmfc\include\atlalloc.h
;	COMDAT ??$AtlMultiply@I@ATL@@YAJPAIII@Z
_TEXT	SEGMENT
_i64Result$ = -12					; size = 8
_piResult$ = 8						; size = 4
_iLeft$ = 12						; size = 4
_iRight$ = 16						; size = 4
??$AtlMultiply@I@ATL@@YAJPAIII@Z PROC			; ATL::AtlMultiply<unsigned int>, COMDAT

; 150  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec d0 00 00
	00		 sub	 esp, 208		; 000000d0H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 30 ff ff
	ff		 lea	 edi, DWORD PTR [ebp-208]
  00012	b9 34 00 00 00	 mov	 ecx, 52			; 00000034H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd

; 151  : 	unsigned __int64 i64Result=static_cast<unsigned __int64>(iLeft) * static_cast<unsigned __int64>(iRight);

  0001e	8b 45 0c	 mov	 eax, DWORD PTR _iLeft$[ebp]
  00021	f7 65 10	 mul	 DWORD PTR _iRight$[ebp]
  00024	89 45 f4	 mov	 DWORD PTR _i64Result$[ebp], eax
  00027	89 55 f8	 mov	 DWORD PTR _i64Result$[ebp+4], edx

; 152  : 	if(i64Result>UINT_MAX)

  0002a	83 7d f8 00	 cmp	 DWORD PTR _i64Result$[ebp+4], 0
  0002e	77 06		 ja	 SHORT $LN4@AtlMultipl
  00030	83 7d f4 ff	 cmp	 DWORD PTR _i64Result$[ebp], -1
  00034	76 0f		 jbe	 SHORT $LN1@AtlMultipl
$LN4@AtlMultipl:

; 153  : 	{
; 154  : 		return HRESULT_FROM_WIN32(ERROR_ARITHMETIC_OVERFLOW);

  00036	68 16 02 00 00	 push	 534			; 00000216H
  0003b	e8 00 00 00 00	 call	 _HRESULT_FROM_WIN32
  00040	83 c4 04	 add	 esp, 4
  00043	eb 0a		 jmp	 SHORT $LN2@AtlMultipl
$LN1@AtlMultipl:

; 155  : 	}
; 156  : 	*piResult=static_cast<unsigned int _ATL_W64>(i64Result);

  00045	8b 45 f4	 mov	 eax, DWORD PTR _i64Result$[ebp]
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _piResult$[ebp]
  0004b	89 01		 mov	 DWORD PTR [ecx], eax

; 157  : 	return S_OK;

  0004d	33 c0		 xor	 eax, eax
$LN2@AtlMultipl:

; 158  : }

  0004f	5f		 pop	 edi
  00050	5e		 pop	 esi
  00051	5b		 pop	 ebx
  00052	81 c4 d0 00 00
	00		 add	 esp, 208		; 000000d0H
  00058	3b ec		 cmp	 ebp, esp
  0005a	e8 00 00 00 00	 call	 __RTC_CheckEsp
  0005f	8b e5		 mov	 esp, ebp
  00061	5d		 pop	 ebp
  00062	c3		 ret	 0
??$AtlMultiply@I@ATL@@YAJPAIII@Z ENDP			; ATL::AtlMultiply<unsigned int>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\windows kits\8.1\include\shared\winerror.h
;	COMDAT _HRESULT_FROM_WIN32
_TEXT	SEGMENT
tv68 = -196						; size = 4
_x$ = 8							; size = 4
_HRESULT_FROM_WIN32 PROC				; COMDAT

; 26297: FORCEINLINE HRESULT HRESULT_FROM_WIN32(unsigned long x) { return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT) (((x) & 0x0000FFFF) | (FACILITY_WIN32 << 16) | 0x80000000);}

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec c4 00 00
	00		 sub	 esp, 196		; 000000c4H
  00009	53		 push	 ebx
  0000a	56		 push	 esi
  0000b	57		 push	 edi
  0000c	8d bd 3c ff ff
	ff		 lea	 edi, DWORD PTR [ebp-196]
  00012	b9 31 00 00 00	 mov	 ecx, 49			; 00000031H
  00017	b8 cc cc cc cc	 mov	 eax, -858993460		; ccccccccH
  0001c	f3 ab		 rep stosd
  0001e	83 7d 08 00	 cmp	 DWORD PTR _x$[ebp], 0
  00022	7f 0b		 jg	 SHORT $LN3@HRESULT_FR
  00024	8b 45 08	 mov	 eax, DWORD PTR _x$[ebp]
  00027	89 85 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], eax
  0002d	eb 1b		 jmp	 SHORT $LN4@HRESULT_FR
$LN3@HRESULT_FR:
  0002f	8b 4d 08	 mov	 ecx, DWORD PTR _x$[ebp]
  00032	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00038	81 c9 00 00 07
	00		 or	 ecx, 458752		; 00070000H
  0003e	81 c9 00 00 00
	80		 or	 ecx, -2147483648	; 80000000H
  00044	89 8d 3c ff ff
	ff		 mov	 DWORD PTR tv68[ebp], ecx
$LN4@HRESULT_FR:
  0004a	8b 85 3c ff ff
	ff		 mov	 eax, DWORD PTR tv68[ebp]
  00050	5f		 pop	 edi
  00051	5e		 pop	 esi
  00052	5b		 pop	 ebx
  00053	8b e5		 mov	 esp, ebp
  00055	5d		 pop	 ebp
  00056	c3		 ret	 0
_HRESULT_FROM_WIN32 ENDP
_TEXT	ENDS
END
